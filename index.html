


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>WCA 2025 - Liam's Guide</title>
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Trebuchet MS', 'Lucida Sans', Tahoma, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
            position: relative;
        }

        /* Main Container */
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 10px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: white;
            border-radius: 20px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin-bottom: 15px;
        }

        .header h1 {
            font-size: 24px;
            color: #5a67d8;
            margin-bottom: 5px;
        }

        .header .subtitle {
            font-size: 16px;
            color: #666;
        }

        /* Navigation */
        .nav-bar {
            background: white;
            border-radius: 15px;
            padding: 10px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .back-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: transform 0.2s;
        }

        .back-btn:active {
            transform: scale(0.95);
        }

        .nav-title {
            flex: 1;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #4a5568;
        }

        /* Screen Container */
        .screen {
            display: none;
            flex: 1;
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            overflow-y: auto;
            animation: slideIn 0.3s ease-out;
        }

        .screen.active {
            display: block;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Home Screen */
        .countdown-box {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .countdown-box h3 {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .countdown-box .event-name {
            font-size: 18px;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .countdown-box .time {
            font-size: 24px;
            font-weight: bold;
        }

        .countdown-box .countdown-message {
            font-size: 16px;
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            font-weight: bold;
        }

        /* Menu Buttons */
        .menu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .menu-btn {
            background: white;
            border: 3px solid #e2e8f0;
            border-radius: 20px;
            padding: 25px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .menu-btn:active {
            transform: scale(0.95);
        }

        .menu-btn .icon {
            font-size: 40px;
            margin-bottom: 10px;
            display: block;
        }

        .menu-btn .label {
            font-size: 16px;
            font-weight: bold;
            color: #4a5568;
        }

        .menu-btn.browse { background-color: #ffd93d; border-color: #fbcb0a; }
        .menu-btn.predictions { background-color: #6bcf7f; border-color: #4caf50; }
        .menu-btn.results { background-color: #ff9a9e; border-color: #ff6b6b; }
        .menu-btn.games { background-color: #a8edea; border-color: #5ed3cf; }
        .menu-btn.scores { background-color: #fbc2eb; border-color: #f89ec7; }
        .menu-btn.save { background-color: #c2e9fb; border-color: #81d4fa; }

        /* Browse Mode Selection */
        .browse-mode-selection {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 30px;
        }

        .mode-card {
            background: white;
            border: 3px solid #e2e8f0;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-card:active {
            transform: scale(0.98);
            background: #f7fafc;
        }

        .mode-icon {
            font-size: 50px;
            margin-bottom: 15px;
        }

        .mode-title {
            font-size: 24px;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 10px;
        }

        .mode-desc {
            font-size: 16px;
            color: #718096;
        }

        /* Event Browser */
        .event-browser-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #f7fafc;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .arrow-btn {
            background: #5a67d8;
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .arrow-btn:active {
            transform: scale(0.9);
        }

        .current-event {
            text-align: center;
            flex: 1;
        }

        .current-event .event-name {
            font-size: 24px;
            font-weight: bold;
            color: #2d3748;
        }

        .current-event .event-time {
            font-size: 16px;
            color: #718096;
            margin-top: 5px;
        }

        /* Event Tabs (hidden on mobile, shown on tablet) */
        .event-tabs {
            display: none;
        }

        /* Event Grid */
        .event-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .event-card {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .event-card:active {
            transform: scale(0.95);
        }

        .event-card .event-icon {
            font-size: 30px;
            margin-bottom: 5px;
        }

        .event-card .event-name {
            font-size: 12px;
            color: #4a5568;
        }

        .event-card.has-finalists {
            background: linear-gradient(135deg, #f9d976 0%, #f39f86 100%);
            border-color: #f39f86;
        }

        .event-card.has-finalists .finals-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ff6b6b;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }

        /* Competitor List */
        .competitor-list {
            margin-top: 20px;
        }

        .competitor-card {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .competitor-card:active {
            transform: scale(0.98);
            background: #e2e8f0;
        }

        .competitor-photo {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
            border: 3px solid #e2e8f0;
        }

        .competitor-info {
            flex: 1;
        }

        .competitor-name {
            font-size: 18px;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .competitor-country {
            font-size: 14px;
            color: #718096;
            margin-bottom: 5px;
        }

        .competitor-medals {
            display: flex;
            gap: 10px;
            font-size: 14px;
        }

        .medal {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        /* Prediction System */
        .prediction-slots {
            margin: 20px 0;
        }

        .prediction-slot {
            background: #f7fafc;
            border: 3px dashed #cbd5e0;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .prediction-slot.filled {
            border-style: solid;
            border-color: #4caf50;
            background: #e6fffa;
        }

        .prediction-slot:active {
            transform: scale(0.98);
        }

        .prediction-slot .rank {
            font-size: 30px;
            margin-bottom: 10px;
        }

        .prediction-slot .placeholder {
            font-size: 16px;
            color: #718096;
        }

        .prediction-slot .selected-name {
            font-size: 18px;
            font-weight: bold;
            color: #2d3748;
        }

        .clear-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #ff6b6b;
            color: white;
            border: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
        }

        /* Competitor Grid for Selection */
        .competitor-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .competitor-select-card {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .competitor-select-card.selected {
            background: #e2e8f0;
            border-color: #a0aec0;
            opacity: 0.5;
        }

        .competitor-select-card:active:not(.selected) {
            transform: scale(0.95);
            background: #bee3f8;
        }

        .competitor-select-card img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-bottom: 5px;
            object-fit: cover;
        }

        .competitor-select-card .name {
            font-size: 12px;
            font-weight: bold;
            color: #2d3748;
        }

        /* Game Styles */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f7fafc;
            border-radius: 15px;
        }

        .question-counter {
            font-size: 18px;
            font-weight: bold;
            color: #4a5568;
        }

        .game-score {
            font-size: 20px;
            font-weight: bold;
            color: #48bb78;
        }

        .question-box {
            background: #f7fafc;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .question-text {
            font-size: 20px;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 20px;
        }

        .question-photo {
            width: 150px;
            height: 150px;
            border-radius: 15px;
            object-fit: cover;
            margin: 0 auto 20px;
            border: 5px solid #e2e8f0;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .option-btn {
            background: white;
            border: 3px solid #e2e8f0;
            border-radius: 15px;
            padding: 20px;
            font-size: 18px;
            font-weight: bold;
            color: #2d3748;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .option-btn:active {
            transform: scale(0.98);
        }

        .option-btn.correct {
            background: #48bb78;
            color: white;
            border-color: #38a169;
            animation: correctPulse 0.6s ease-out;
        }

        .option-btn.incorrect {
            background: #f56565;
            color: white;
            border-color: #e53e3e;
            animation: shake 0.5s ease-out;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .progress-bar {
            background: #e2e8f0;
            height: 10px;
            border-radius: 5px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #48bb78 0%, #38a169 100%);
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s ease-out;
        }

        /* Results Screen */
        .results-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .results-card h2 {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .results-card .final-score {
            font-size: 48px;
            font-weight: bold;
            margin: 20px 0;
        }

        .results-card .message {
            font-size: 20px;
            margin-bottom: 20px;
        }

        /* Save/Load Styles */
        .save-code-box {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
        }

        .save-code {
            font-size: 24px;
            font-weight: bold;
            color: #5a67d8;
            letter-spacing: 2px;
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 2px dashed #cbd5e0;
        }

        #qrcode {
            margin: 20px auto;
            padding: 10px;
            background: white;
            border-radius: 10px;
            display: inline-block;
        }

        #qrcode img {
            display: block;
        }

        .input-field {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            text-align: center;
            margin: 10px 0;
            font-family: inherit;
        }

        /* Action Buttons */
        .action-btn {
            background: #5a67d8;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            margin: 10px 5px;
        }

        .action-btn:active {
            transform: scale(0.95);
        }

        .action-btn.secondary {
            background: #718096;
        }

        .action-btn.success {
            background: #48bb78;
        }

        .action-btn.danger {
            background: #f56565;
        }

        /* Info Box */
        .info-box {
            background: #e6fffa;
            border: 2px solid #4fd1c5;
            border-radius: 15px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            font-size: 14px;
            color: #234e52;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 24px;
            color: #718096;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }
@keyframes glow {
    0% { box-shadow: 0 0 5px rgba(229, 62, 62, 0.5); }
    50% { box-shadow: 0 0 20px rgba(229, 62, 62, 0.8), 0 0 30px rgba(229, 62, 62, 0.6); }
    100% { box-shadow: 0 0 5px rgba(229, 62, 62, 0.5); }
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}
        /* Responsive Design */
        @media (max-width: 480px) {
            .container {
                padding: 5px;
            }
            
            .header h1 {
                font-size: 20px;
            }
            
            .menu-grid {
                grid-template-columns: 1fr;
            }
            
            .event-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .competitor-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Tablet Event Tabs */
        @media (min-width: 768px) {
            .event-browser-header {
                display: none;
            }
            
            .event-tabs {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 20px;
                padding: 15px;
                background: #f7fafc;
                border-radius: 20px;
            }
            
            .event-tab {
                padding: 10px 20px;
                background: white;
                border: 2px solid #e2e8f0;
                border-radius: 15px;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 14px;
                text-align: center;
            }
            
            .event-tab.active {
                background: #5a67d8;
                color: white;
                border-color: #5a67d8;
            }
            
            .event-tab.disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            
            .browse-mode-selection {
                flex-direction: row;
                gap: 30px;
                justify-content: center;
            }
            
            .mode-card {
                max-width: 300px;
            }
        }

        /* Landscape Mode */
        @media (orientation: landscape) and (max-height: 600px) {
            .container {
                max-width: 100%;
            }
            
            .menu-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        /* Initial screen display */
        #homeScreen { display: block; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>🎉 WCA 2025 - Hi Liam! 🎉</h1>
            <div class="subtitle">Seattle Championship Guide</div>
        </div>

        <!-- Navigation Bar -->
        <div class="nav-bar" id="navBar" style="display: none;">
            <button class="back-btn" onclick="WCAGuideApp.goBack()">
                ← Back
            </button>
            <div class="nav-title" id="navTitle">Home</div>
        </div>

        <!-- Home Screen -->
        <div class="screen active" id="homeScreen">
            <div class="countdown-box" id="nextEventBox">
                <h3>⏰ Next Finals</h3>
                <div class="event-name" id="nextEventName">Loading...</div>
                <div class="time" id="nextEventTime">Calculating...</div>
                <div class="countdown-message" id="nextEventMessage"></div>
            </div>

            <div class="countdown-box" id="mainEventBox" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                <h3>🏆 3x3x3 Finals</h3>
                <div class="time" id="mainEventTime">Sunday at 4:15 PM</div>
                <div class="countdown-message" id="mainEventMessage"></div>
            </div>

            <div class="menu-grid">
                <div class="menu-btn browse" onclick="WCAGuideApp.browse.handleBrowseClick()">
                    <span class="icon">📚</span>
                    <span class="label">Competitors<br>& Top 10</span>
                </div>

                <div class="menu-btn predictions" onclick="WCAGuideApp.navigate('predictions')">
                    <span class="icon">🎯</span>
                    <span class="label">Make My<br>Predictions</span>
                </div>

                <div class="menu-btn results" onclick="WCAGuideApp.navigate('results')">
                    <span class="icon">🏁</span>
                    <span class="label">How Did<br>My Picks Do?</span>
                </div>

                <div class="menu-btn games" onclick="WCAGuideApp.navigate('games')">
                    <span class="icon">🎮</span>
                    <span class="label">Play<br>Games</span>
                </div>

                <div class="menu-btn scores" onclick="WCAGuideApp.navigate('scores')">
                    <span class="icon">🏆</span>
                    <span class="label">Game<br>Scores</span>
                </div>

                <div class="menu-btn save" onclick="WCAGuideApp.navigate('save')">
                    <span class="icon">💾</span>
                    <span class="label">Save/<br>Load</span>
                </div>
            </div>

            <div class="info-box">
                ℹ️ Game facts are for fun!<br>
                Found a mistake? Let us know!
            </div>
        </div>

        <!-- Browse Competitors Screen -->
        <div class="screen" id="browseScreen">
            <h2>Which do you want to see?</h2>
            <div class="browse-mode-selection">
                <div class="mode-card" onclick="WCAGuideApp.browse.selectMode('world')">
                    <div class="mode-icon">👥</div>
                    <div class="mode-title">World Top 10</div>
                    <div class="mode-desc">See the best ever!</div>
                </div>
                <div class="mode-card" onclick="WCAGuideApp.browse.selectMode('finalists')">
                    <div class="mode-icon">🏆</div>
                    <div class="mode-title">2025 Finalists</div>
                    <div class="mode-desc">Who made finals!</div>
                </div>
            </div>
             <div class="mode-card" onclick="WCAGuideApp.browse.selectMode('tournament')">
        <div class="mode-icon">🏅</div>
        <div class="mode-title">2025 Final Results</div>
        <div class="mode-desc">See tournament results!</div>
    </div>
        </div>

<!-- Event Browser Screen (Phone) -->
<div class="screen" id="eventBrowserScreen">
    <div class="event-browser-header">
        <button class="arrow-btn" onclick="WCAGuideApp.browse.prevEvent()">←</button>
        <div class="current-event">
            <div class="event-name" id="currentEventName">5x5x5</div>
            <div class="event-time" id="currentEventTime">Thursday</div>
        </div>
        <button class="arrow-btn" onclick="WCAGuideApp.browse.nextEvent()">→</button>
    </div>
    <div class="competitor-list" id="eventCompetitorList"></div>
</div>
<!-- Finalist Event Selection Screen (Mobile) -->
<div class="screen" id="finalistEventSelectScreen">
    <h2 style="text-align: center; margin-bottom: 20px;">Choose an Event</h2>
    <div id="finalistEventList"></div>
</div>
        <!-- Competitor Detail Screen -->
        <div class="screen" id="competitorDetailScreen">
            <div id="competitorDetail"></div>
        </div>

        <!-- Predictions Screen -->
        <div class="screen" id="predictionsScreen">
            <h2>Choose an Event to Predict</h2>
            <div id="predictionEventList"></div>
        </div>

        <!-- Make Predictions Screen -->
        <div class="screen" id="makePredictionsScreen">
            <h2 id="makePredictionsTitle">Make Your Predictions</h2>
            <div class="prediction-slots" id="predictionSlots"></div>
            <div style="text-align: center;">
                <button class="action-btn danger" onclick="WCAGuideApp.predictions.clearAll()">Clear All</button>
                <button class="action-btn success" onclick="WCAGuideApp.predictions.savePredictions()">I'm Done!</button>
            </div>
        </div>

        <!-- Competitor Selection Screen -->
        <div class="screen" id="competitorSelectScreen">
            <h2 id="competitorSelectTitle">Pick a Competitor</h2>
            <div class="competitor-grid" id="competitorSelectGrid"></div>
        </div>

        <!-- Results Screen -->
        <div class="screen" id="resultsScreen">
            <h2>Check Your Results</h2>
            <div id="resultsEventList"></div>
        </div>

        <!-- Enter Results Screen -->
        <div class="screen" id="enterResultsScreen">
            <h2 id="enterResultsTitle">How Did They Do?</h2>
            <div id="enterResultsContent"></div>
        </div>

        <!-- Games Menu Screen -->
        <div class="screen" id="gamesScreen">
            <h2>Choose a Game</h2>
            <div class="menu-grid">
                <div class="menu-btn" style="background: #ffd93d;" onclick="WCAGuideApp.games.selectGame('faces')">
                    <span class="icon">😊</span>
                    <span class="label">Faces<br>Quiz</span>
                </div>
                <div class="menu-btn" style="background: #6bcf7f;" onclick="WCAGuideApp.games.selectGame('countries')">
                    <span class="icon">🌍</span>
                    <span class="label">Countries<br>Match</span>
                </div>
                <div class="menu-btn" style="background: #ff9a9e;" onclick="WCAGuideApp.games.selectGame('speed')">
                    <span class="icon">🏃</span>
                    <span class="label">Speed<br>Stats</span>
                </div>
                <div class="menu-btn" style="background: #a8edea;" onclick="WCAGuideApp.games.selectGame('facts')">
                    <span class="icon">📚</span>
                    <span class="label">Cube<br>Facts</span>
                </div>
                <div class="menu-btn" style="background: #fbc2eb;" onclick="WCAGuideApp.games.selectGame('mixed')">
                    <span class="icon">❓</span>
                    <span class="label">Mix It<br>Up!</span>
                </div>
                <div class="menu-btn" style="background: #ddd6f3;" onclick="WCAGuideApp.games.selectGame('tournament')">
    <span class="icon">🏆</span>
    <span class="label">2025 WCA<br>Finals</span>
</div>
            </div>
        </div>

        <!-- Game Difficulty Screen -->
        <div class="screen" id="gameDifficultyScreen">
            <h2 id="gameDifficultyTitle">Choose Difficulty</h2>
            <div style="text-align: center; margin-top: 50px;">
                <button class="action-btn" style="background: #48bb78; font-size: 24px; padding: 20px 40px; margin: 20px;" 
                        onclick="WCAGuideApp.games.startGame('easy')">
                    Easy ⭐
                </button>
                <button class="action-btn" style="background: #f6ad55; font-size: 24px; padding: 20px 40px; margin: 20px;" 
                        onclick="WCAGuideApp.games.startGame('medium')">
                    Medium ⭐⭐
                </button>
                <button class="action-btn" style="background: #f56565; font-size: 24px; padding: 20px 40px; margin: 20px;" 
                        onclick="WCAGuideApp.games.startGame('hard')">
                    Hard ⭐⭐⭐
                </button>
            </div>
        </div>

        <!-- Game Play Screen -->
        <div class="screen" id="gamePlayScreen">
            <div class="game-header">
                <div class="question-counter" id="questionCounter">Question 1 of 10</div>
                <div class="game-score" id="gameScore">Score: 0⭐</div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 10%"></div>
            </div>
            <div class="question-box" id="questionBox"></div>
            <div class="options-grid" id="optionsGrid"></div>
        </div>

        <!-- Game Results Screen -->
        <div class="screen" id="gameResultsScreen">
            <div class="results-card">
                <h2>🎉 Great Job! 🎉</h2>
                <div class="final-score" id="finalScore">8/10</div>
                <div class="message" id="resultMessage">You're a cube expert!</div>
                <button class="action-btn" style="background: white; color: #5a67d8;" 
                        onclick="WCAGuideApp.navigate('games')">Play Again</button>
            </div>
        </div>

        <!-- Scores Screen -->
        <div class="screen" id="scoresScreen">
            <h2>Your Game Scores</h2>
            <div id="scoresList"></div>
        </div>

        <!-- Save/Load Screen -->
        <div class="screen" id="saveScreen">
            <h2>Save & Load</h2>
            
            <div class="save-code-box">
                <h3>📱 Your Save Code</h3>
                <div id="qrcode" style="margin: 20px auto; width: 256px; height: 256px;"></div>
                <div class="save-code" id="saveCode">LOADING...</div>
                <button class="action-btn" onclick="WCAGuideApp.storage.copyCode()">Copy Code</button>
                <button class="action-btn secondary" onclick="WCAGuideApp.storage.refreshSave()">Update Code</button>
            </div>

            <div class="save-code-box">
                <h3>📥 Load Data</h3>
                <p style="margin-bottom: 15px;">Scan QR code or enter manual code:</p>
                <input type="text" class="input-field" id="loadCodeInput" 
                       placeholder="Enter code here">
                <button class="action-btn success" onclick="WCAGuideApp.storage.loadData()">Load Data</button>
            </div>

            <div class="info-box">
                💡 Tip: Take a photo of the QR code or write down your manual code to save your progress!
            </div>
        </div>
    </div>

    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js" 
            onerror="console.warn('QR code library failed to load. Manual codes will still work.')"></script>

    <script>
        // Initialize competitor data from CSV processing
        window.competitorsData = {
            // This would normally be populated from your CSV data
            // For now, the app will use the sample data with 8 competitors
        };
        
        // Quick test - log when script loads
        console.log('WCA 2025 Guide App Loading...');
    </script>

    <script>
        // Main App Object
        const WCAGuideApp = {
            // Data storage
            competitors: {},
            facts: {},
            gameConfig: {},
            eventResults: {},
             currentScreen: 'home',
    previousScreen: null,
    navigationHistory: [],
            userProgress: {
    predictions: {},
    gameScores: {},
    viewedCompetitors: []
},
            
        // Initialize app
// Initialize app
async init() {
    try {
        console.log('1. Starting init...');
        
        // Show loading state
        this.showLoadingState();
        console.log('2. Loading state shown');
        
        // Load all data from JSON files
        await this.loadAllData();
        console.log('3. Data loaded');
        
        // Load saved progress
        this.loadProgress();
        console.log('4. Progress loaded');
        
        // Update finals status based on current time
        this.updateFinalsStatus();
        console.log('5. Finals status updated');
        
        // Initialize screens AFTER all data is loaded
        this.browse.init();
        console.log('6. Browse initialized');
        this.predictions.init();
        console.log('7. Predictions initialized');
        this.results.init();
        console.log('8. Results initialized');
        this.games.init();
        console.log('9. Games initialized');
        this.scores.init();
        console.log('10. Scores initialized');
        this.storage.init();
        console.log('11. Storage initialized');
        
        // Hide loading state (this restores the home screen HTML)
        this.hideLoadingState();
        console.log('12. Loading state hidden');
        
        // Start countdown timer AFTER hideLoadingState restores the DOM elements
        this.startCountdown();
        console.log('13. Countdown started');
        
    } catch (error) {
        console.error('Error initializing app:', error);
        alert('Error loading app data. Please check your internet connection and refresh.');
    }
},
            // Show loading state
            showLoadingState() {
                const screens = document.querySelectorAll('.screen');
                screens.forEach(s => s.style.display = 'none');
                
                const homeScreen = document.getElementById('homeScreen');
                homeScreen.style.display = 'block';
                homeScreen.innerHTML = '<div class="loading">Loading WCA 2025 Guide...</div>';
            },
            
            // Hide loading state and restore home screen
            hideLoadingState() {
                const homeScreen = document.getElementById('homeScreen');
                homeScreen.innerHTML = `
                    <div class="countdown-box" id="nextEventBox">
                        <h3>⏰ Next Finals</h3>
                        <div class="event-name" id="nextEventName">Loading...</div>
                        <div class="time" id="nextEventTime">Calculating...</div>
                        <div class="countdown-message" id="nextEventMessage"></div>
                    </div>

                    <div class="countdown-box" id="mainEventBox" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                        <h3>🏆 3x3x3 Finals</h3>
                        <div class="time" id="mainEventTime">Sunday at 4:15 PM</div>
                        <div class="countdown-message" id="mainEventMessage"></div>
                    </div>

                    <div class="menu-grid">
                        <div class="menu-btn browse" onclick="WCAGuideApp.browse.handleBrowseClick()">
                            <span class="icon">📚</span>
                            <span class="label">Competitors<br>& Top 10</span>
                        </div>

                        <div class="menu-btn predictions" onclick="WCAGuideApp.navigate('predictions')">
                            <span class="icon">🎯</span>
                            <span class="label">Make My<br>Predictions</span>
                        </div>

                        <div class="menu-btn results" onclick="WCAGuideApp.navigate('results')">
                            <span class="icon">🏁</span>
                            <span class="label">How Did<br>My Picks Do?</span>
                        </div>

                        <div class="menu-btn games" onclick="WCAGuideApp.navigate('games')">
                            <span class="icon">🎮</span>
                            <span class="label">Play<br>Games</span>
                        </div>

                        <div class="menu-btn scores" onclick="WCAGuideApp.navigate('scores')">
                            <span class="icon">🏆</span>
                            <span class="label">Game<br>Scores</span>
                        </div>

                        <div class="menu-btn save" onclick="WCAGuideApp.navigate('save')">
                            <span class="icon">💾</span>
                            <span class="label">Save/<br>Load</span>
                        </div>
                    </div>

                    <div class="info-box">
                        ℹ️ Game facts are for fun!<br>
                        Found a mistake? Let us know!
                    </div>
                `;
            },
            
           async loadAllData() {
    try {
        // Load competitors (the only file with real data)
        const response = await fetch('./data/competitors.json');
        if (response.ok) {
            this.competitors = await response.json();
            console.log(`Loaded ${Object.keys(this.competitors).length} competitors`);
        } else {
            console.error('Failed to load competitors');
             
        }
        
        // Use hardcoded facts instead of empty facts.json
        this.loadFacts();
        
        // gameConfig is already hardcoded in the app
        console.log('Using hardcoded game configuration');
// Add finals schedule
this.gameConfig.finals = {
    "555bf": { time: "2025-07-03T08:45:00", status: "complete" },
    "555": { time: "2025-07-04T17:25:00", status: "ready" },
    "clock": { time: "2025-07-04T17:50:00", status: "ready" },
    "333oh": { time: "2025-07-04T18:40:00", status: "pending" },
    "pyram": { time: "2025-07-04T18:15:00", status: "ready" },
    "777": { time: "2025-07-05T18:40:00", status: "pending" },
    "minx": { time: "2025-07-05T17:50:00", status: "pending" },
    "444": { time: "2025-07-05T17:25:00", status: "pending" },
    "222": { time: "2025-07-05T18:15:00", status: "pending" },
    "skewb": { time: "2025-07-06T14:25:00", status: "pending" },
    "444bf": { time: "2025-07-06T08:30:00", status: "pending" },
    "666": { time: "2025-07-06T14:50:00", status: "pending" },
    "333bf": { time: "2025-07-06T15:40:00", status: "pending" },
    "sq1": { time: "2025-07-06T15:15:00", status: "pending" },
    "333": { time: "2025-07-06T16:15:00", status: "pending" },
    // Add these after the competition events
"flight": { 
    time: "2025-07-06T21:00:00", 
    status: "pending",
    icon: "✈️",
    name: "Flight Home",
    messages: [
        '🧳 What an amazing WCA Championship! Time to pack up!',
                '🏆 Did you get all your autographs? Check your bag!',
                '📸 Hope you took lots of photos with the champions!',
                '🎯 Practice those algorithms on the plane ride home!',
                '✈️ Next stop: Home! Keep cubing!',
                '🎪 What was your favorite event? Think about it!',
                '🤝 Did you make new cubing friends? Stay in touch!',
                '🌟 Remember: You saw history being made today!'
    ]
},
"dayafter": { 
    time: "2025-07-07T12:00:00", 
    status: "pending",
    icon: "📅",
    name: "The Day After",
    isStatic: true, // No countdown, just show the message
    message: '🎒 Did you show your friends your WCA souvenirs?'
},
"daytwo": { 
    time: "2025-07-08T12:00:00",
    status: "pending", 
    icon: "📸",
    name: "Share Your Story",
    isStatic: true,
    message: '📱 Time to post those championship photos!'
},
"memories": { 
    time: "2025-07-10T12:00:00",
    status: "pending",
    icon: "🏆",
    name: "WCA 2025 Memories", 
    isStatic: true,
    isFinal: true, // This is the last event
    messages: [
        '🎯 Keep practicing those algorithms!',
            '📸 Look through your championship photos!',
            '🧩 Time to beat your personal records!',
            '🌟 You witnessed cubing history!',
            '🎮 Play the games to stay sharp!',
            '📚 Study the champions\' techniques!',
            '🏃 Getting ready for the next comp?',
            '✨ What an amazing experience!'
    ]
}
};

// Add event timings for countdown messages
this.gameConfig.eventTimings = {
    default: { snacks: 45, seats: 25 },
    "333": { snacks: 45, seats: 120 }
};
        // Add actual results - update these as results come in
this.gameConfig.actualResults = {
  // Update these in your actualResults:

"555bf": {
    "1st": "2016CHAP04",  // Stanley Chapel
    "2nd": "2021PRAS02",  // Simon Praschl
    "3rd": "2017GUTM01",  // Manuel Gutman
    "4th": "2019ECKE02",  // Ryan Eckersley
    "5th": "2019SMIT36"   // Amy Smith
},

"clock": {
    "1st": "2022STOJ03",  // Antoni Stojek
    "2nd": "2021DUNA01",  // Brendyn Dunagan
    "3rd": "2022KAPU01",  // Volodymyr Kapustiansky
    "4th": "2015BARH01",  // Anders Barhaugen
    "5th": "2022SALA09"   // Aarni Salakari
},

"555": {
    "1st": "2016kola02",  // Tymon Kolasiński (note: lowercase 'k')
    "2nd": "2012PARK03",  // Max Park
    "3rd": "2015WANG09",  // Kai-Wen Wang
    "4th": "2019TARA09",  // Timofei Tarasenko
    "5th": "2016INAB01"   // Matty Hiroto Inaba
},
   "333oh": {
    "1st": "2023CUAR03",  // Neo Cuares - Philippines
    "2nd": "2012PARK03",  // Max Park - United States
    "3rd": "2018MURR03",  // Jasper Murray - New Zealand
    "4th": "2017GARR05",  // Luke Garrett - United States
    "5th": "2017TSVE02"   // Alexey Tsvetkov - Russia
},
    "pyram": {
    "1st": "2019SHER10",  // Ezra Shere - United States
    "2nd": "2017NIEL03",  // Michael Nielsen - United States
    "3rd": "2022PLUG01",  // Jonathan Plug - Netherlands
    "4th": "2019MEAD03",  // Kyle Meade - United States
    "5th": "2018HIBS01"   // Jakub Hibszer - Poland
},
    "777": {
    "1st": "2012PARK03",  // Max Park - United States
    "2nd": "2016kola02",  // Tymon Kolasiński - Poland
    "3rd": "2016HUNG08",  // Lim Hung - Malaysia
    "4th": "2017PARK05",  // DongSoo Park - Republic of Korea
    "5th": "2019TARA09"   // Timofei Tarasenko - Russia
},
    "minx": {
    "1st": "2018LOPE22",  // Leandro Martín López - Argentina
    "2nd": "2019TARA09",  // Timofei Tarasenko - Russia
    "3rd": "2017SEOH01",  // Heewon Seo - United States
    "4th": "2015NAIN01",  // Nicolas Naing - United States
    "5th": "2018GRAI01"   // Aidan Grainger - United Kingdom
},
    "444": {
    "1st": "2010WEYE02",  // Sebastian Weyer - Germany
    "2nd": "2019TARA09",  // Timofei Tarasenko - Russia
    "3rd": "2016kola02",  // Tymon Kolasiński - Poland
    "4th": "2016INAB01",  // Matty Hiroto Inaba - United States
    "5th": "2012BEAH01"   // Ciarán Beahan - Ireland
},
   "222": {
    "1st": "2016FEIS01",  // Sujan Feist - United States
    "2nd": "2019WANY36",  // Yiheng Wang - China
    "3rd": "2018KHAN28",  // Zayn Khanani - United States
    "4th": "2021ZAJD03",  // Teodor Zajder - Poland
    "5th": "2018ZHUA10"   // Ethan Zhuang - United States
},
    
   "444bf": {
    "1st": "2016CHAP04",  // Stanley Chapel - United States
    "2nd": "2019ECKE02",  // Ryan Eckersley - United Kingdom
    "3rd": "2021PRAS02",  // Simon Praschl - Austria
    "4th": "2021TRIP01",  // Michael Tripodi - Australia
    "5th": "2014CHEN37"   // Liam Chen - United States
},

  "333bf": {
    "1st": "2019EGGI02",  // Charlie Eggins - Australia
    "2nd": "2015CHER07",  // Tommy Cherry - United States
    "3rd": "2017GUTM01",  // Manuel Gutman - Argentina
    "4th": "2015PARK08",  // Jeff Park - United States
    "5th": "2017SWOR01"   // Noah Swor - United States
},
   "skewb": {
    "1st": "2022SAMS03",  // Ignacy Samselski - Poland
    "2nd": "2019REDI02",  // Dominic Redisi - United States
    "3rd": "2018KHAN28",  // Zayn Khanani - United States
    "4th": "2023LANG03",  // Alex Rosado Saez de Langarica - Spain
    "5th": "2022SUSS01"   // Dean Jacob Adamo Susskind - United States
},
"666": {
    "1st": "2012PARK03",  // Max Park - United States
    "2nd": "2016kola02",  // Tymon Kolasiński - Poland
    "3rd": "2018LICH05",  // Henry Lichner - United States
    "4th": "2013NAHM01",  // Seung Hyuk Nahm - Republic of Korea
    "5th": "2019TARA09"   // Timofei Tarasenko - Russia
},
"sq1": {
    "1st": "2017AGGA01",  // Sameer Aggarwal - United States
    "2nd": "2018KHAN26",  // Hassan Khanani - United States
    "3rd": "2021DUNA01",  // Brendyn Dunagan - United States
    "4th": "2014DETL01",  // Rasmus Stub Detlefsen - Denmark
    "5th": "2013JOHN10"   // Brian Johnson - United States
},
  "333": {
    "1st": "2019WANY36",  // Yiheng Wang (王艺衡) - China
    "2nd": "2023GENG02",  // Xuanyi Geng (耿暄一) - China
    "3rd": "2016kola02",  // Tymon Kolasiński - Poland
    "4th": "2023CAOQ01",  // Qixian Cao (曹岂娴) - China
    "5th": "2016INAB01"   // Matty Hiroto Inaba - United States
},
    "333fm": {
    "1st": "2018GIBS04",  // Levi Gibson - United States
    "2nd": "?????",       // Adrien Neveu - France
    "3rd": "?????",       // Wojciech Rogoziński - Poland
    "4th": "2015KUCA01"   // Carter Kucala - United States
},
"333mbf": {
    "1st": "2022TAOA01",  // Andrew Tao - United States
    "2nd": "2015MACD03",  // James Macdiarmid - New Zealand
    "3rd": "?????",       // Joshua Gao - United States
    "4th": "2013WALL03",  // Daniel Wallin - Sweden
    "5th": "2011BANS02"   // Shivam Bansal - India
}
};
        if (!this.gameConfig.events) {
    this.gameConfig.events = {
        "222": { name: "2x2x2", icon: "🎲" },
        "333": { name: "3x3x3", icon: "📦" },
        "444": { name: "4x4x4", icon: "🎯" },
        "555": { name: "5x5x5", icon: "⭐" },
        "666": { name: "6x6x6", icon: "🌟" },
        "777": { name: "7x7x7", icon: "💫" },
        "333bf": { name: "3x3x3 Blindfolded", icon: "🙈" },
        "333fm": { name: "3x3x3 Fewest Moves", icon: "🎯" },
        "333oh": { name: "3x3x3 One-Handed", icon: "✋" },
        "333mbf": { name: "3x3x3 Multi-Blind", icon: "🙈" },
        "444bf": { name: "4x4x4 Blindfolded", icon: "🙈" },
        "555bf": { name: "5x5x5 Blindfolded", icon: "🙈" },
        "clock": { name: "Clock", icon: "🕐" },
        "minx": { name: "Megaminx", icon: "🔷" },
        "pyram": { name: "Pyraminx", icon: "🔺" },
        "skewb": { name: "Skewb", icon: "💠" },
        "sq1": { name: "Square-1", icon: "⬜" },
          "flight": { name: "Flight Home", icon: "✈️" },
    "dayafter": { name: "The Day After", icon: "📅" },
    "daytwo": { name: "Share Your Story", icon: "📸" },
    "memories": { name: "WCA 2025 Memories", icon: "🏆" }
    };
}
if (!this.gameConfig.finalsStatus) {
    this.gameConfig.finalsStatus = {
        "555bf": "complete",
        "555": "ready",
        "clock": "ready"
    };
}
        
    } catch (error) {
        console.error('Error loading data:', error);
        // Fallback to sample data
         
        this.loadFacts();
    }
},
updateFinalsStatus() {
    // Add this safety check
    if (!this.gameConfig.finals) {
        console.log('Finals not loaded yet, skipping status update');
        return;
    }
    
    const now = new Date();
    
    Object.entries(this.gameConfig.finals).forEach(([eventId, data]) => {
        const eventTime = new Date(data.time);
        const timeDiff = now - eventTime;
        
        // If qualifying should have happened (30 min after start time for most events)
        if (timeDiff > 1800000) { // 30 minutes
            if (this.gameConfig.finalsStatus[eventId] === 'pending') {
                this.gameConfig.finalsStatus[eventId] = 'ready';
            }
        }
        
        // If event is complete (2+ hours after start)
        if (timeDiff > 7200000) { // 2 hours
            if (this.gameConfig.finalsStatus[eventId] !== 'complete') {
                this.gameConfig.finalsStatus[eventId] = 'complete';
            }
        }
    });
},
           goBack() {
    if (this.navigationHistory.length > 0) {
        // Get the previous screen from history
        const previousScreen = this.navigationHistory.pop();
        
        // Navigate without adding to history (to avoid loops)
        this.currentScreen = previousScreen;
        
        // Hide all screens
        document.querySelectorAll('.screen').forEach(s => {
            s.classList.remove('active');
            s.style.display = 'none';
        });
        
        // Show previous screen
        const screenElement = document.getElementById(previousScreen + 'Screen');
        if (screenElement) {
            screenElement.classList.add('active');
            screenElement.style.display = 'block';
        }
        
        // Update nav title
        document.getElementById('navTitle').textContent = this.getScreenTitle(previousScreen);
        
        // Special handling for certain screens
        if (previousScreen === 'eventBrowser' && window.innerWidth >= 768) {
            this.browse.renderEventTabs();
        }
        
        // CLEAR BROWSE MODE IF GOING HOME
        if (previousScreen === 'home') {
            this.browse.mode = null;
            this.navigationHistory = [];
            document.getElementById('navBar').style.display = 'none';
            
            // Restart countdown when returning home
            if (!this.countdownInterval) {
                this.startCountdown();
            }
        }
    } else {
        // If no history, go home
        this.navigate('home');
    }
},
            // Countdown functionality
            countdownInterval: null,
            currentEventStartTime: null,

            startCountdown() {
                // Update immediately
                this.updateCountdown();
                
                // Update every second
                this.countdownInterval = setInterval(() => {
                    this.updateCountdown();
                }, 1000);
            },

            updateCountdown() {
                const now = new Date();
                const nextEvent = this.getNextEvent(now);
                const main333Event = this.get333Event(now);

                // Update next event countdown
                if (nextEvent) {
                    this.updateNextEventDisplay(nextEvent, now);
                } else {
                    // All events complete
                    document.getElementById('nextEventName').textContent = '🎉 Championships Complete!';
                    document.getElementById('nextEventTime').textContent = 'What an amazing competition!';
                    document.getElementById('nextEventMessage').textContent = '🏆 Thanks for following along!';
                }

                // Update 3x3x3 countdown
                if (main333Event) {
                    this.updateMainEventDisplay(main333Event, now);
                }
            },

            getNextEvent(now) {
                let nextEvent = null;
                let minTime = Infinity;

                Object.entries(this.gameConfig.finals).forEach(([eventId, data]) => {
                    const eventTime = new Date(data.time);
                    const timeDiff = eventTime - now;

                    // Find the next event (positive time difference)
                    if (timeDiff > 0 && timeDiff < minTime) {
                        minTime = timeDiff;
                        nextEvent = {
                            id: eventId,
                            name: this.gameConfig.events[eventId].name,
                            icon: this.gameConfig.events[eventId].icon,
                            time: eventTime,
                            status: data.status
                        };
                    }
                });

                // If no future events, check if we're still showing results for the last event
                if (!nextEvent) {
                    // Find the most recent past event
                    let lastEvent = null;
                    let maxTime = -Infinity;
                    
                    Object.entries(this.gameConfig.finals).forEach(([eventId, data]) => {
                        const eventTime = new Date(data.time);
                        const timeDiff = now - eventTime;
                        
                        if (timeDiff > 0 && timeDiff < 600000 && timeDiff > maxTime) { // Within 10 minutes
                            maxTime = timeDiff;
                            lastEvent = {
                                id: eventId,
                                name: this.gameConfig.events[eventId].name,
                                icon: this.gameConfig.events[eventId].icon,
                                time: eventTime,
                                status: data.status
                            };
                        }
                    });
                    
                    return lastEvent;
                }

                return nextEvent;
            },

            get333Event(now) {
                const data = this.gameConfig.finals['333'];
                if (!data) return null;

                return {
                    id: '333',
                    name: '3x3x3',
                    icon: '📦',
                    time: new Date(data.time),
                    status: data.status
                };
            },

            updateNextEventDisplay(event, now) {
                const timeDiff = event.time - now;
                const minutes = Math.floor(timeDiff / 60000);
                const hours = Math.floor(minutes / 60);
                const days = Math.floor(hours / 24);

                const eventNameEl = document.getElementById('nextEventName');
                const timeEl = document.getElementById('nextEventTime');
                const messageEl = document.getElementById('nextEventMessage');

                eventNameEl.textContent = `${event.icon} ${event.name}`;

                // Check if event is happening now (within 10 minutes after start)
                if (timeDiff < 0 && timeDiff > -600000) {
                    // Don't show results entry for events that were complete before predictions
                    if (this.gameConfig.finalsStatus[event.id] === 'complete' && 
                        !Object.keys(this.userProgress.predictions[event.id] || {}).length) {
                        timeEl.textContent = 'Finals Complete';
                        messageEl.textContent = '';
                        return;
                    }
                    
                    timeEl.textContent = 'Happening NOW!';
                    if (timeDiff > -120000) { // First 2 minutes
                        messageEl.textContent = '💥 Finals have started! 💥';
                        messageEl.style.animation = 'pulse 1s infinite';
                    } else if (timeDiff > -600000) { // 2-10 minutes
                        messageEl.textContent = '📝 Enter how your picks did!';
                        messageEl.style.animation = '';
                    }
                    return;
                }

                // Format countdown
                let countdownText = '';
                if (days > 0) {
                    countdownText = `${days} day${days > 1 ? 's' : ''}, ${hours % 24}h ${minutes % 60}m`;
                } else if (hours > 0) {
                    countdownText = `${hours}h ${minutes % 60}m ${Math.floor((timeDiff % 60000) / 1000)}s`;
                } else if (minutes > 0) {
                    countdownText = `${minutes}m ${Math.floor((timeDiff % 60000) / 1000)}s`;
                } else {
                    countdownText = `${Math.floor(timeDiff / 1000)}s`;
                }

                timeEl.textContent = countdownText;

                // Get timing config
                const timings = this.gameConfig.eventTimings[event.id] || this.gameConfig.eventTimings.default;

                // Special Sunday marathon handling for seat saving
                if (event.id === '666' && now.getDay() === 0) { // Sunday
                    if (minutes >= 120 && minutes <= 180) { // 2-3 hours before
                        messageEl.textContent = '🏃 Consider someone saving seats today!';
                        return;
                    }
                }

                // Set message based on time remaining
                if (minutes <= 5) {
                    messageEl.textContent = '🚀 Let\'s GO!';
                    messageEl.style.color = '#ff6b6b';
                } else if (minutes <= 10) {
                    messageEl.textContent = '🎯 Get ready!';
                } else if (minutes <= timings.seats) {
                    messageEl.textContent = '🪑 Time to get your seat!';
                } else if (minutes <= timings.snacks) {
                    messageEl.textContent = '🍿 Get your snacks ready!';
                } else {
                    messageEl.textContent = '';
                }
            },

          updateMainEventDisplay(event, now) {
    const timeDiff = event.time - now;
    const minutes = Math.floor(timeDiff / 60000);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    const timeEl = document.getElementById('mainEventTime');
    const messageEl = document.getElementById('mainEventMessage');
    const titleEl = document.querySelector('#mainEventBox h3');

    // Update title if this is a special event
    if (event.name && event.icon) {
        titleEl.textContent = `${event.icon} ${event.name}`;
    }

    // Handle static events (no countdown)
    if (event.isStatic && timeDiff < 0) {
        timeEl.textContent = event.name;
        
        // Handle rotating messages or single message
        if (event.messages) {
            const messageIndex = Math.floor(now.getTime() / 60000) % event.messages.length;
            messageEl.textContent = event.messages[messageIndex];
        } else {
            messageEl.textContent = event.message;
        }
        
        // Clear any animations
        messageEl.style.animation = '';
        
        // Set gradient based on event
        if (event.name === 'Flight Home') {
            document.getElementById('mainEventBox').style.background = 
                'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        } else if (event.name.includes('Memories')) {
            document.getElementById('mainEventBox').style.background = 
                'linear-gradient(135deg, #fa709a 0%, #fee140 100%)';
        }
        
        return;
    }

    // Handle events that are happening now
    if (timeDiff < 0 && timeDiff > -600000 && !event.isStatic) {
        timeEl.textContent = '🏆 HAPPENING NOW! 🏆';
        messageEl.textContent = 'The moment we\'ve been waiting for!';
        messageEl.style.animation = 'pulse 1s infinite';
        return;
    }

    // Handle rotating messages for countdown events (like flight)
    if (event.messages && timeDiff > 0) {
        const messageIndex = Math.floor(now.getTime() / 30000) % event.messages.length;
        messageEl.textContent = event.messages[messageIndex];
        
        // Format countdown
        if (hours > 0) {
            timeEl.textContent = `Departure in ${hours}h ${minutes % 60}m`;
        } else if (minutes > 0) {
            timeEl.textContent = `Departure in ${minutes}m`;
        } else {
            timeEl.textContent = `Departure in ${Math.floor(timeDiff / 1000)}s`;
        }
        
        // Set flight gradient
        document.getElementById('mainEventBox').style.background = 
            'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        return;
    }

    // Original 3x3x3 countdown code
    titleEl.textContent = '🏆 3x3x3 Finals';
    
    // Format time
    let timeText = 'Sunday at 4:15 PM';
    if (days <= 1) {
        if (hours > 0) {
            timeText = `In ${hours}h ${minutes % 60}m`;
        } else if (minutes > 0) {
            timeText = `In ${minutes}m`;
        } else {
            timeText = `In ${Math.floor(timeDiff / 1000)}s`;
        }
    }

    timeEl.textContent = timeText;

    // Special 3x3x3 messages
    if (minutes <= 5) {
        messageEl.textContent = '🚀 THE MAIN EVENT! Let\'s GO!';
        messageEl.style.animation = 'pulse 1s infinite';
    } else if (minutes <= 10) {
        messageEl.textContent = '📱 Phones ready for the big moment!';
    } else if (minutes <= 15) {
        messageEl.textContent = '🎯 Find your saved seat & get ready!';
    } else if (minutes <= 30) {
        messageEl.textContent = '⚠️ Arena filling up! Get your seat NOW!';
    } else if (minutes <= 45) {
        messageEl.textContent = '🪑 Get seats for 3x3x3! Prime spots going fast!';
    } else if (minutes <= 60) {
        messageEl.textContent = '🏆 3x3x3 FINALS IN 1 HOUR! Plan your day!';
    } else if (minutes <= 120) {
        messageEl.textContent = '🏃 Send Dad to save seats NOW!';
    } else if (now.getDay() === 0) { // Sunday
        const stopMessagingTime = new Date(event.time);
        stopMessagingTime.setHours(13, 50); // 1:50 PM
        
        if (now < stopMessagingTime) {
            messageEl.textContent = 'It\'s going to be CROWDED!';
        } else {
            messageEl.textContent = '';
        }
    } else {
        messageEl.textContent = days > 0 ? `${days} day${days > 1 ? 's' : ''} to go!` : '';
    }
},

  navigate(screen) {
    // Clear countdown when leaving home
    if (this.countdownInterval && screen !== 'home') {
        clearInterval(this.countdownInterval);
        this.countdownInterval = null;
    }
    
    // Track navigation history
    if (this.currentScreen && this.currentScreen !== screen) {
        this.navigationHistory.push(this.currentScreen);
        // Keep only last 10 screens to prevent memory issues
        if (this.navigationHistory.length > 10) {
            this.navigationHistory.shift();
        }
    }
    this.currentScreen = screen;
    
    // Hide all screens
    document.querySelectorAll('.screen').forEach(s => {
        s.classList.remove('active');
        s.style.display = 'none';
    });
    
    // Show selected screen
    const screenElement = document.getElementById(screen + 'Screen');
    if (screenElement) {
        screenElement.classList.add('active');
        screenElement.style.display = 'block';
        
        // Special handling for certain screens
        if (screen === 'scores') {
            // Reload progress from localStorage before showing scores
            this.loadProgress();
            this.scores.renderScores();
        }
    }

    // Update nav bar
    const navBar = document.getElementById('navBar');
    const navTitle = document.getElementById('navTitle');
    
    if (screen === 'home') {
        navBar.style.display = 'none';
        
        // CLEAR NAVIGATION STATE when going home
        this.browse.mode = null;
        this.navigationHistory = [];
        
        // Restart countdown when returning home
        if (!this.countdownInterval) {
            this.startCountdown();
        }
    } else {
        navBar.style.display = 'flex';
        navTitle.textContent = this.getScreenTitle(screen);
    }
},
            getScreenTitle(screen) {
                const titles = {
                    browse: 'Competitors & Rankings',
                    eventBrowser: 'Browse Competitors',
                    competitorList: 'Competitors',
                    competitorDetail: 'Competitor Details',
                    predictions: 'Make Predictions',
                    makePredictions: 'Pick Your Winners',
                    competitorSelect: 'Choose Competitor',
                    results: 'Check Results',
                    enterResults: 'Enter Results',
                    games: 'Play Games',
                    gameDifficulty: 'Choose Difficulty',
                    gamePlay: 'Playing Game',
                    gameResults: 'Game Over!',
                    scores: 'Your Scores',
                    finalistEventSelect: '2025 WCA Finalists',
                    save: 'Save & Load'
                };
                return titles[screen] || 'WCA 2025';
            },

            // Load/Save Progress
         loadProgress() {
    const saved = localStorage.getItem('wca2025_liam');
    if (saved) {
        try {
            const data = JSON.parse(saved);
            this.userProgress = data;
        } catch (e) {
            console.error('Error loading progress:', e);
        }
    }
},

            saveProgress() {
                localStorage.setItem('wca2025_liam', JSON.stringify(this.userProgress));
            },

            // Load sample data for testing
            loadSampleData() {
                // Extended sample data with more competitors for testing
                this.competitors = {
                    "2015PARK01": {
                        name: "Max Park",
                        country: "USA",
                        countryFull: "United States",
                        photoUrl: "https://avatars.worldcubeassociation.org/uploads/user/avatar/2015PARK01/1580357802.jpg",
                        photoThumbUrl: "https://avatars.worldcubeassociation.org/uploads/user/avatar/2015PARK01/1580357802_thumb.jpg",
                        gender: "m",
                        competitions: 125,
                        medals: { gold: 523, silver: 234, bronze: 112, total: 869 },
                        topEvents: ["333", "444", "555"],
                        worldRankings: {
                            "333": { single: 1, singleTime: 346, average: 1, averageTime: 563 },
                            "444": { single: 2, singleTime: 1825, average: 2, averageTime: 2156 },
                            "555": { single: 1, singleTime: 3492, average: 1, averageTime: 3867 }
                        },
                        difficulty: "easy",
                        isFinalist: { "333": true, "555": true }
                    },
                    "2022WANG09": {
                        name: "Yiheng Wang",
                        country: "CHN",
                        countryFull: "China",
                        photoUrl: "https://via.placeholder.com/150",
                        photoThumbUrl: "https://via.placeholder.com/150",
                        gender: "m",
                        competitions: 15,
                        medals: { gold: 45, silver: 12, bronze: 8, total: 65 },
                        topEvents: ["222", "333"],
                        worldRankings: {
                            "222": { single: 1, singleTime: 49, average: 1, averageTime: 123 },
                            "333": { single: 3, singleTime: 447, average: 5, averageTime: 645 }
                        },
                        difficulty: "easy",
                        isFinalist: { "333": true }
                    },
                    "2016KOLA02": {
                        name: "Tymon Kolasiński",
                        country: "POL",
                        countryFull: "Poland",
                        photoUrl: "https://via.placeholder.com/150",
                        photoThumbUrl: "https://via.placeholder.com/150",
                        gender: "m",
                        competitions: 89,
                        medals: { gold: 312, silver: 189, bronze: 98, total: 599 },
                        topEvents: ["333", "444", "555"],
                        worldRankings: {
                            "333": { single: 4, singleTime: 389, average: 3, averageTime: 598 },
                            "444": { single: 3, singleTime: 1893, average: 4, averageTime: 2234 },
                            "555": { single: 2, singleTime: 3549, average: 2, averageTime: 3901 }
                        },
                        difficulty: "easy",
                        isFinalist: { "555": true }
                    },
                    "2019GARR01": {
                        name: "Luke Garrett",
                        country: "USA", 
                        countryFull: "United States",
                        photoUrl: "https://via.placeholder.com/150",
                        photoThumbUrl: "https://via.placeholder.com/150",
                        gender: "m",
                        competitions: 67,
                        medals: { gold: 203, silver: 147, bronze: 89, total: 439 },
                        topEvents: ["333", "333oh"],
                        worldRankings: {
                            "333": { single: 8, singleTime: 412, average: 12, averageTime: 634 },
                            "333oh": { single: 15, singleTime: 834, average: 18, averageTime: 1123 }
                        },
                        difficulty: "easy",
                        isFinalist: { "333": true, "333oh": true }
                    },
                    "2013NAHRA01": {
                        name: "Seung Hyuk Nahm",
                        country: "KOR",
                        countryFull: "Republic of Korea",
                        photoUrl: "https://via.placeholder.com/150",
                        photoThumbUrl: "https://via.placeholder.com/150",
                        gender: "m",
                        competitions: 112,
                        medals: { gold: 287, silver: 198, bronze: 145, total: 630 },
                        topEvents: ["555", "666", "777"],
                        worldRankings: {
                            "555": { single: 6, singleTime: 3745, average: 8, averageTime: 4170 },
                            "666": { single: 4, singleTime: 7234, average: 5, averageTime: 7856 },
                            "777": { single: 5, singleTime: 12456, average: 7, averageTime: 13234 }
                        },
                        difficulty: "easy",
                        isFinalist: { "555": true }
                    },
                    "2009ZEMD01": {
                        name: "Feliks Zemdegs",
                        country: "AUS",
                        countryFull: "Australia",
                        photoUrl: "https://via.placeholder.com/150",
                        photoThumbUrl: "https://via.placeholder.com/150",
                        gender: "m",
                        competitions: 134,
                        medals: { gold: 689, silver: 234, bronze: 89, total: 1012 },
                        topEvents: ["333", "444", "555", "333oh"],
                        worldRankings: {
                            "333": { single: 9, singleTime: 423, average: 15, averageTime: 645 },
                            "444": { single: 12, singleTime: 2134, average: 14, averageTime: 2456 },
                            "555": { single: 14, singleTime: 3856, average: 11, averageTime: 4232 }
                        },
                        difficulty: "easy",
                        isFinalist: { "555": true }
                    },
                    "2017WONG08": {
                        name: "Jonathan Wang",
                        country: "CAN",
                        countryFull: "Canada",
                        photoUrl: "https://via.placeholder.com/150",
                        photoThumbUrl: "https://via.placeholder.com/150",
                        gender: "m",
                        competitions: 45,
                        medals: { gold: 89, silver: 67, bronze: 45, total: 201 },
                        topEvents: ["clock"],
                        worldRankings: {
                            "clock": { single: 2, singleTime: 264, average: 1, averageTime: 286 }
                        },
                        difficulty: "easy",
                        isFinalist: { "clock": true }
                    },
                    "2018THOM02": {
                        name: "Carter Thomas",
                        country: "USA",
                        countryFull: "United States",
                        photoUrl: "https://via.placeholder.com/150",
                        photoThumbUrl: "https://via.placeholder.com/150",
                        gender: "m",
                        competitions: 38,
                        medals: { gold: 67, silver: 45, bronze: 34, total: 146 },
                        topEvents: ["clock", "pyram"],
                        worldRankings: {
                            "clock": { single: 5, singleTime: 291, average: 4, averageTime: 334 },
                            "pyram": { single: 89, singleTime: 234, average: 112, averageTime: 367 }
                        },
                        difficulty: "easy",
                        isFinalist: { "clock": true }
                    }
                };
                
                // Add isFinalist data for the ones we know
                const clockFinalistNames = ["Jonathan Wang", "Carter Thomas"];
                const fiveFinalistNames = ["Tymon Kolasiński", "Max Park", "Seung Hyuk Nahm", "Feliks Zemdegs"];
                
                Object.values(this.competitors).forEach(comp => {
                    if (!comp.isFinalist) comp.isFinalist = {};
                    
                    if (clockFinalistNames.includes(comp.name)) {
                        comp.isFinalist.clock = true;
                    }
                    if (fiveFinalistNames.includes(comp.name)) {
                        comp.isFinalist["555"] = true;
                    }
                });
            },

            // Update finalists based on results
            updateFinalists() {
                // Clock finalists
                const clockFinalists = [
                    "Jonathan Wang", "Carter Thomas", "Alessandro Diomampo", "Antoni Stojek",
                    "Anders Barhaugen", "Jasper Wolfe-Tham", "Jaidon Poraminthara Lin",
                    "Aarni Salakari", "Eryk Kasperek", "Volodymyr Kapustianskyi",
                    "Brendyn Dunagan", "Drake Denton Richard", "Quinn Maloney",
                    "Alex Moscibroda", "Clement D. Tucker", "Kyle Jones",
                    "Aaron Jake Wong", "Zachary Cribb", "Eddie Artze", "Greyson James"
                ];

                const fiveFinalists = [
                    "Tymon Kolasiński", "Max Park", "Henry Lichner", "Timofei Tarasenko",
                    "Kai-Wen Wang", "Seung Hyuk Nahm", "Matty Hiroto Inaba",
                    "Burno Li Chak Kwan", "Feliks Zemdegs", "Ciarán Beahan",
                    "Lim Hung", "Patrick Ponce", "Richard Delacoste", "Emmanuel Kao",
                    "Arhaan Sareen", "Sebastian Weyer", "Inigo Miguel B. Palisoc",
                    "Varun Mohanraj", "Dwyane Ramos", "Brendyn Dunagan"
                ];

                // Match names to competitors and update isFinalist
                Object.entries(this.competitors).forEach(([id, comp]) => {
                    // Initialize isFinalist if it doesn't exist
                    if (!comp.isFinalist) {
                        comp.isFinalist = {};
                    }
                    
                    // Check if competitor made clock finals
                    if (clockFinalists.some(name => 
                        comp.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(comp.name.toLowerCase())
                    )) {
                        comp.isFinalist.clock = true;
                    }

                    // Check if competitor made 5x5x5 finals
                    if (fiveFinalists.some(name => 
                        comp.name.toLowerCase().includes(name.toLowerCase()) || 
                        name.toLowerCase().includes(comp.name.toLowerCase())
                    )) {
                        comp.isFinalist["555"] = true;
                    }
                });

                // Update finals status
                this.gameConfig.finalsStatus["555"] = "ready";
                this.gameConfig.finalsStatus["clock"] = "ready";
            },

            // Load facts
            loadFacts() {
                this.facts = {
                    general: {
                        easy: [
                            {
                                id: "fact_001",
                                question: "How many stickers are on a standard 3x3x3 Rubik's Cube?",
                                answer: "54",
                                options: ["36", "48", "54", "60"],
                                category: "cube_basics"
                            },
                            {
                                id: "fact_002",
                                question: "What does WCA stand for?",
                                answer: "World Cube Association",
                                options: ["World Cube Association", "World Cubing Academy", "World Competition Alliance", "World Cube Academy"],
                                category: "organization"
                            },
                            {
                                id: "fact_003",
                                question: "Who invented the Rubik's Cube?",
                                answer: "Ernő Rubik",
                                options: ["Ernő Rubik", "Feliks Zemdegs", "Jessica Fridrich", "Ron van Bruchem"],
                                category: "history"
                            },
                            {
                                id: "fact_004",
                                question: "How many seconds do you get to inspect the cube before solving?",
                                answer: "15 seconds",
                                options: ["10 seconds", "15 seconds", "20 seconds", "30 seconds"],
                                category: "rules"
                            },
                            {
                                id: "fact_005",
                                question: "What was the Rubik's Cube originally called?",
                                answer: "Magic Cube",
                                options: ["Puzzle Cube", "Magic Cube", "Wonder Cube", "Brain Cube"],
                                category: "history"
                            },
                            {
                                id: "fact_006",
                                question: "What year was the Rubik's Cube invented?",
                                answer: "1974",
                                options: ["1974", "1980", "1982", "1990"],
                                category: "history"
                            },
                            {
                                id: "fact_007",
                                question: "How many official WCA events are there currently?",
                                answer: "17",
                                options: ["12", "15", "17", "20"],
                                category: "organization"
                            },
                            {
                                id: "fact_008",
                                question: "What does DNF mean in cubing?",
                                answer: "Did Not Finish",
                                options: ["Do Not Flip", "Did Not Finish", "Does Not Function", "Did Not Follow"],
                                category: "terms"
                            },
                            {
                                id: "fact_009",
                                question: "Which country is the Rubik's Cube from?",
                                answer: "Hungary",
                                options: ["USA", "Hungary", "Germany", "Japan"],
                                category: "history"
                            },
                            {
                                id: "fact_010",
                                question: "How many colors are on a standard Rubik's Cube?",
                                answer: "6",
                                options: ["4", "5", "6", "8"],
                                category: "cube_basics"
                            },
                            {
                                id: "fact_011",
                                question: "What's the most popular speedcubing method?",
                                answer: "CFOP",
                                options: ["CFOP", "Roux", "ZZ", "Beginner's Method"],
                                category: "methods"
                            },
                            {
                                id: "fact_012",
                                question: "What shape is a Pyraminx?",
                                answer: "Pyramid",
                                options: ["Cube", "Pyramid", "Dodecahedron", "Sphere"],
                                category: "puzzles"
                            },
                            {
                                id: "fact_013",
                                question: "How many pieces does a 3x3x3 cube have?",
                                answer: "26",
                                options: ["20", "24", "26", "27"],
                                category: "cube_basics"
                            },
                            {
                                id: "fact_014",
                                question: "What does 'sub' mean in cubing? (like sub-10)",
                                answer: "Under/Less than",
                                options: ["Under/Less than", "Substitute", "Submarine", "Subject"],
                                category: "terms"
                            },
                            {
                                id: "fact_015",
                                question: "Which event uses only one hand?",
                                answer: "3x3x3 One-Handed",
                                options: ["3x3x3 Blindfolded", "3x3x3 One-Handed", "3x3x3 Fewest Moves", "Clock"],
                                category: "events"
                            },
                            {
                                id: "fact_016",
                                question: "What's the center piece of a Rubik's Cube called?",
                                answer: "Center",
                                options: ["Center", "Middle", "Core", "Heart"],
                                category: "cube_basics"
                            },
                            {
                                id: "fact_017",
                                question: "How many edge pieces does a 3x3x3 have?",
                                answer: "12",
                                options: ["8", "10", "12", "14"],
                                category: "cube_basics"
                            },
                            {
                                id: "fact_018",
                                question: "How many corner pieces does a 3x3x3 have?",
                                answer: "8",
                                options: ["4", "6", "8", "10"],
                                category: "cube_basics"
                            },
                            {
                                id: "fact_019",
                                question: "What event uses a timer shaped like a clock?",
                                answer: "Clock",
                                options: ["Timer", "Clock", "Stopwatch", "Watch"],
                                category: "events"
                            },
                            {
                                id: "fact_020",
                                question: "Which cube size is the smallest?",
                                answer: "2x2x2",
                                options: ["1x1x1", "2x2x2", "3x3x3", "4x4x4"],
                                category: "puzzles"
                            }
                        ],
                        medium: [
                            {
                                id: "fact_021",
                                question: "When was the World Cube Association (WCA) established?",
                                answer: "2004",
                                options: ["2000", "2003", "2004", "2006"],
                                category: "organization"
                            },
                            {
                                id: "fact_022",
                                question: "Where was the first World Championship held in 1982?",
                                answer: "Budapest",
                                options: ["New York", "Budapest", "Tokyo", "London"],
                                category: "history"
                            },
                            {
                                id: "fact_023",
                                question: "Who was the first World Champion in 1982?",
                                answer: "Minh Thai",
                                options: ["Minh Thai", "Jessica Fridrich", "Ron van Bruchem", "Ernő Rubik"],
                                category: "history"
                            },
                            {
                                id: "fact_024",
                                question: "What is 'God's Number' for a 3x3x3 cube?",
                                answer: "20 moves",
                                options: ["15 moves", "18 moves", "20 moves", "26 moves"],
                                category: "theory"
                            },
                            {
                                id: "fact_025",
                                question: "Which event was discontinued after 2019?",
                                answer: "3x3x3 With Feet",
                                options: ["3x3x3 With Feet", "Magic", "Master Magic", "3x3x3 Multi-Blind"],
                                category: "events"
                            },
                            {
                                id: "fact_026",
                                question: "How often are World Championships held?",
                                answer: "Every 2 years",
                                options: ["Every year", "Every 2 years", "Every 3 years", "Every 4 years"],
                                category: "organization"
                            },
                            {
                                id: "fact_027",
                                question: "Who founded the WCA?",
                                answer: "Ron van Bruchem and Tyson Mao",
                                options: ["Jessica Fridrich", "Feliks Zemdegs", "Ron van Bruchem and Tyson Mao", "Ernő Rubik"],
                                category: "organization"
                            },
                            {
                                id: "fact_028",
                                question: "What does CFOP stand for?",
                                answer: "Cross, F2L, OLL, PLL",
                                options: ["Cross, F2L, OLL, PLL", "Cross, First, Orient, Permute", "Corner, Face, Orient, Place", "Cross, Face, Order, Position"],
                                category: "methods"
                            },
                            {
                                id: "fact_029",
                                question: "Over how many Rubik's Cubes have been sold worldwide?",
                                answer: "400 million",
                                options: ["100 million", "250 million", "400 million", "600 million"],
                                category: "history"
                            },
                            {
                                id: "fact_030",
                                question: "What was Minh Thai's winning time in 1982?",
                                answer: "22.95 seconds",
                                options: ["15.95 seconds", "22.95 seconds", "35.95 seconds", "45.95 seconds"],
                                category: "records"
                            },
                            {
                                id: "fact_031",
                                question: "Which method starts with a 1x2x3 block?",
                                answer: "Roux",
                                options: ["CFOP", "Roux", "ZZ", "Petrus"],
                                category: "methods"
                            },
                            {
                                id: "fact_032",
                                question: "How many algorithms are in 2-Look OLL?",
                                answer: "7",
                                options: ["5", "7", "9", "11"],
                                category: "methods"
                            },
                            {
                                id: "fact_033",
                                question: "What does F2L stand for?",
                                answer: "First Two Layers",
                                options: ["First Two Layers", "Face To Layer", "Front Two Lines", "Fast Two Looks"],
                                category: "methods"
                            },
                            {
                                id: "fact_034",
                                question: "Which country has Feliks Zemdegs represented?",
                                answer: "Australia",
                                options: ["USA", "Australia", "Germany", "Poland"],
                                category: "competitors"
                            },
                            {
                                id: "fact_035",
                                question: "What year did speedcubing have a 20+ year gap?",
                                answer: "1982-2003",
                                options: ["1980-2000", "1982-2003", "1985-2005", "1990-2010"],
                                category: "history"
                            },
                            {
                                id: "fact_036",
                                question: "What does '+' mean in a 3x3x3 result (like 8.45+)?",
                                answer: "2-second penalty",
                                options: ["Extra move", "2-second penalty", "Plus one solve", "Positive result"],
                                category: "rules"
                            },
                            {
                                id: "fact_037",
                                question: "How many solves in an Average of 5?",
                                answer: "5 (best and worst dropped)",
                                options: ["3", "4", "5 (best and worst dropped)", "6"],
                                category: "rules"
                            },
                            {
                                id: "fact_038",
                                question: "What's the biggest NxN cube in WCA?",
                                answer: "7x7x7",
                                options: ["5x5x5", "6x6x6", "7x7x7", "8x8x8"],
                                category: "events"
                            },
                            {
                                id: "fact_039",
                                question: "What method did Minh Thai likely use in 1982?",
                                answer: "Layer by layer",
                                options: ["CFOP", "Layer by layer", "Roux", "Corners First"],
                                category: "history"
                            },
                            {
                                id: "fact_040",
                                question: "What does OLL solve?",
                                answer: "Orient Last Layer",
                                options: ["Orient Last Layer", "One Last Look", "Outer Last Layer", "Only Last Layer"],
                                category: "methods"
                            }
                        ],
                        hard: [
                            {
                                id: "fact_041",
                                question: "How many possible positions does a 3x3x3 have?",
                                answer: "43 quintillion",
                                options: ["43 million", "43 billion", "43 trillion", "43 quintillion"],
                                category: "theory"
                            },
                            {
                                id: "fact_042",
                                question: "How fast can robots solve Rubik's Cubes?",
                                answer: "Under 0.5 seconds",
                                options: ["Under 5 seconds", "Under 2 seconds", "Under 1 second", "Under 0.5 seconds"],
                                category: "technology"
                            },
                            {
                                id: "fact_043",
                                question: "Who popularized the CFOP method?",
                                answer: "Jessica Fridrich",
                                options: ["Ernő Rubik", "Jessica Fridrich", "Minh Thai", "Tyson Mao"],
                                category: "methods"
                            },
                            {
                                id: "fact_044",
                                question: "How many OLL algorithms are there in full CFOP?",
                                answer: "57",
                                options: ["21", "40", "57", "78"],
                                category: "methods"
                            },
                            {
                                id: "fact_045",
                                question: "How many PLL algorithms are there?",
                                answer: "21",
                                options: ["15", "21", "27", "33"],
                                category: "methods"
                            },
                            {
                                id: "fact_046",
                                question: "Which method has the lowest average movecount?",
                                answer: "Roux",
                                options: ["CFOP", "Roux", "ZZ", "Petrus"],
                                category: "methods"
                            },
                            {
                                id: "fact_047",
                                question: "What was Rubik's original purpose for the cube?",
                                answer: "Teaching 3D geometry",
                                options: ["A toy", "Teaching 3D geometry", "Art project", "Mathematical research"],
                                category: "history"
                            },
                            {
                                id: "fact_048",
                                question: "What is the average movecount for Roux method?",
                                answer: "45-50 moves",
                                options: ["40-45 moves", "45-50 moves", "50-55 moves", "55-60 moves"],
                                category: "methods"
                            },
                            {
                                id: "fact_049",
                                question: "Who was the first to break the 5-second barrier?",
                                answer: "Lucas Etter",
                                options: ["Feliks Zemdegs", "Lucas Etter", "Max Park", "Mats Valk"],
                                category: "records"
                            },
                            {
                                id: "fact_050",
                                question: "What does EOLine stand for in ZZ method?",
                                answer: "Edge Orientation Line",
                                options: ["Edge Orientation Line", "End Of Line", "Equal Orientation Line", "Easy Orientation Line"],
                                category: "methods"
                            },
                            {
                                id: "fact_051",
                                question: "How many ZBLL algorithms are there?",
                                answer: "493",
                                options: ["293", "393", "493", "593"],
                                category: "methods"
                            },
                            {
                                id: "fact_052",
                                question: "What's the WCA ID format for someone who started in 2003?",
                                answer: "2003XXXX01",
                                options: ["XXXX2003", "2003XXXX01", "03XXXXXX", "2003-XXXX"],
                                category: "organization"
                            },
                            {
                                id: "fact_053",
                                question: "What is the exact number in 43 quintillion?",
                                answer: "43,252,003,274,489,856,000",
                                options: ["43,252,003,274,489,856,000", "43,525,200,327,448,985,600", "43,225,003,274,489,856,000", "43,252,003,274,498,856,000"],
                                category: "theory"
                            },
                            {
                                id: "fact_054",
                                question: "Which year did online cubing communities really begin?",
                                answer: "1999",
                                options: ["1995", "1997", "1999", "2001"],
                                category: "history"
                            },
                            {
                                id: "fact_055",
                                question: "What's the time limit for 3x3x3 in competition?",
                                answer: "10 minutes",
                                options: ["5 minutes", "10 minutes", "15 minutes", "No limit"],
                                category: "rules"
                            },
                            {
                                id: "fact_056",
                                question: "What's the movecount for optimal Cross in CFOP?",
                                answer: "8 moves maximum",
                                options: ["6 moves", "7 moves", "8 moves maximum", "9 moves"],
                                category: "methods"
                            },
                            {
                                id: "fact_057",
                                question: "How many competitors at WCA 2025?",
                                answer: "Over 2,000",
                                options: ["Over 1,000", "Over 1,500", "Over 2,000", "Over 2,500"],
                                category: "current"
                            },
                            {
                                id: "fact_058",
                                question: "What percentage of cubers use CFOP?",
                                answer: "~90%",
                                options: ["~70%", "~80%", "~90%", "~95%"],
                                category: "methods"
                            },
                            {
                                id: "fact_059",
                                question: "How many countries at WCA 2025?",
                                answer: "74",
                                options: ["64", "69", "74", "79"],
                                category: "current"
                            },
                            {
                                id: "fact_060",
                                question: "How many F2L algorithms exist?",
                                answer: "41",
                                options: ["31", "36", "41", "46"],
                                category: "methods"
                            }
                        ]
                    }
                };
            },
// Browse module
            browse: {
                mode: null, // 'world' or 'finalists'
                currentEventIndex: 0,
                eventOrder: ['555bf', '555', 'clock', '333oh', 'pyram', '777', 'minx', '444', '222', 'skewb', '444bf', '666', '333bf', 'sq1', '333'],
                
                init() {
                    // Initialize browse system
                },

                handleBrowseClick() {
                    if (this.mode) {
                        // Already selected a mode, go directly to event browser
                        WCAGuideApp.navigate('eventBrowser');
                        if (window.innerWidth >= 768) {
                            this.renderEventTabs();
                        }
                        this.showCurrentEvent();
                    } else {
                        // Show mode selection
                        WCAGuideApp.navigate('browse');
                    }
                },

                checkForExistingMode() {
                    // If already had a mode selected, go directly to event browser
                    if (this.mode) {
                        WCAGuideApp.navigate('eventBrowser');
                        if (window.innerWidth >= 768) {
                            this.renderEventTabs();
                        }
                        this.showCurrentEvent();
                        return true;
                    }
                    return false;
                },

                
                   selectMode(mode) {
    this.mode = mode;
    
    // On mobile, show event selection screen for finalists
    if (mode === 'finalists' && window.innerWidth < 768) {
        WCAGuideApp.navigate('finalistEventSelect');
        this.renderFinalistEventList();
        return; // Exit early for mobile
    }
    
    // Desktop/tablet behavior (unchanged)
    if (mode === 'finalists') {
        // Start with first event that has finalists
        this.currentEventIndex = 0;
        while (this.currentEventIndex < this.eventOrder.length) {
            const eventId = this.eventOrder[this.currentEventIndex];
            const hasFinalists = Object.values(WCAGuideApp.competitors)
                .some(comp => comp.isFinalist && comp.isFinalist[eventId]);
            if (hasFinalists) break;
            this.currentEventIndex++;
        }
    } else {
        this.currentEventIndex = 0;
    }
    
    WCAGuideApp.navigate('eventBrowser');
    
    // Add tablet event tabs if screen is wide enough
    if (window.innerWidth >= 768) {
        this.renderEventTabs();
    }
    
    this.showCurrentEvent();
},
                renderFinalistEventList() {
    const list = document.getElementById('finalistEventList');
    list.innerHTML = '';

    Object.entries(WCAGuideApp.gameConfig.events).forEach(([eventId, event]) => {
        // Check if this event has any finalists
        const hasFinalists = Object.values(WCAGuideApp.competitors)
            .some(comp => comp.isFinalist && comp.isFinalist[eventId]);
        
        if (!hasFinalists) return; // Skip events without finalists
        
        const card = document.createElement('div');
        card.style.cssText = `
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
        `;

        card.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: space-between;">
                <div>
                    <span style="font-size: 24px; margin-right: 10px;">${event.icon}</span>
                    <span style="font-size: 18px; font-weight: bold;">${event.name}</span>
                </div>
            </div>
            <div style="color: #5a67d8; font-weight: bold; margin-top: 10px; text-align: center;">
                Click here to see the finalists! →
            </div>
        `;

        card.onclick = () => {
            this.currentEventIndex = this.eventOrder.indexOf(eventId);
            WCAGuideApp.navigate('eventBrowser');
            this.showCurrentEvent();
        };

        // Add hover effect
        card.onmouseover = () => {
            card.style.transform = 'translateY(-2px)';
            card.style.boxShadow = '0 4px 15px rgba(0,0,0,0.1)';
        };
        card.onmouseout = () => {
            card.style.transform = 'translateY(0)';
            card.style.boxShadow = 'none';
        };

        list.appendChild(card);
    });
},
                renderEventTabs() {
                    const header = document.querySelector('.event-browser-header');
                    if (!header) return;
                    
                    // Create tabs container if it doesn't exist
                    let tabsContainer = document.querySelector('.event-tabs');
                    if (!tabsContainer) {
                        tabsContainer = document.createElement('div');
                        tabsContainer.className = 'event-tabs';
                        header.parentNode.insertBefore(tabsContainer, header.nextSibling);
                    }
                    
                    tabsContainer.innerHTML = '';
                    
                    this.eventOrder.forEach((eventId, index) => {
                        const event = WCAGuideApp.gameConfig.events[eventId];
                        const status = WCAGuideApp.gameConfig.finalsStatus[eventId];
                        
                        const tab = document.createElement('div');
                        tab.className = 'event-tab';
                        
                        if (index === this.currentEventIndex) {
                            tab.classList.add('active');
                        }
                        
                        if (this.mode === 'finalists' && status !== 'ready' && status !== 'complete') {
                            tab.classList.add('disabled');
                        }
                        
                        tab.innerHTML = `
                            <div>${event.icon}</div>
                            <div style="font-size: 12px;">${event.name}</div>
                        `;
                        
                        if (!tab.classList.contains('disabled')) {
                            tab.onclick = () => {
                                this.currentEventIndex = index;
                                this.showCurrentEvent();
                                this.renderEventTabs();
                            };
                        }
                        
                        tabsContainer.appendChild(tab);
                    });
                },

                showCurrentEvent() {
    const eventId = this.eventOrder[this.currentEventIndex];
    const event = WCAGuideApp.gameConfig.events[eventId];
    
    // Update header
    document.getElementById('currentEventName').textContent = 
        `${event.icon} ${event.name}`;
    
    // Get event time
    const eventTime = this.getEventDay(eventId);
    document.getElementById('currentEventTime').textContent = eventTime;
    
    // Update nav title based on mode
    const navTitle = document.getElementById('navTitle');
    if (navTitle) {
        if (this.mode === 'world') {
            navTitle.textContent = 'World Top 10';
        } else if (this.mode === 'finalists') {
            navTitle.textContent = '2025 WCA Finalists';
        }
    }
    
    // Show competitors
    this.showCompetitors(eventId);
},

                getEventDay(eventId) {
                    const eventDate = new Date(WCAGuideApp.gameConfig.finals[eventId]?.time);
                    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    return days[eventDate.getDay()] || 'TBD';
                },

               showCompetitors(eventId) {
    const list = document.getElementById('eventCompetitorList');
    list.innerHTML = '';

    if (this.mode === 'world') {
        // Show world top 10
        const competitors = Object.entries(WCAGuideApp.competitors)
            .filter(([id, comp]) => comp.worldRankings[eventId])
            .sort((a, b) => a[1].worldRankings[eventId].single - b[1].worldRankings[eventId].single)
            .slice(0, 10);

        if (competitors.length === 0) {
            list.innerHTML = '<div style="text-align: center; padding: 50px; color: #718096;">No world ranking data available for this event.</div>';
            return;
        }

        competitors.forEach(([id, comp], index) => {
            const card = this.createCompetitorCard(comp, id, eventId, index + 1);
            list.appendChild(card);
        });
    } else {
        // Show 2025 finalists sorted by seed
        const finalists = Object.entries(WCAGuideApp.competitors)
            .filter(([id, comp]) => comp.isFinalist && comp.isFinalist[eventId])
            .sort((a, b) => {
                const seedA = a[1].wca2025Qualifying?.[eventId]?.seed || 999;
                const seedB = b[1].wca2025Qualifying?.[eventId]?.seed || 999;
                return seedA - seedB;
            })
            .slice(0, 20);

        if (finalists.length === 0) {
            list.innerHTML = '<div style="text-align: center; padding: 50px; color: #718096;">This Data is Unavailable, Please Select a Different Competition</div>';
            return;
        }

        finalists.forEach(([id, comp]) => {
            const card = this.createCompetitorCard(comp, id, eventId, null, true);
            list.appendChild(card);
        });
    }
},
                createCompetitorCard(comp, competitorId, eventId, rank, isFinalist = false) {
    const card = document.createElement('div');
    card.className = 'competitor-card';
    
    const worldRank = comp.worldRankings[eventId]?.single || 'N/A';
    const competitionSeed = comp.wca2025Qualifying?.[eventId]?.seed;
    
    let displayRank;
    if (isFinalist && competitionSeed) {
        displayRank = `
            <div style="font-weight: bold; color: #e53e3e;">🏁 Seed #${competitionSeed}</div>
            <div style="font-size: 12px; color: #4a5568;">🌍 World #${worldRank}</div>
        `;
    } else {
        displayRank = `<div style="font-weight: bold; color: #4a5568;">🌍 World #${worldRank}</div>`;
    }
    
    card.innerHTML = `
        <img src="${comp.photoThumbUrl}" class="competitor-photo" 
             onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2260%22 height=%2260%22%3E%3Crect width=%2260%22 height=%2260%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22 font-size=%2212%22%3ENo Photo%3C/text%3E%3C/svg%3E'"">
        <div class="competitor-info">
            <div class="competitor-name">${comp.name}</div>
            <div class="competitor-country">🌍 ${comp.country}</div>
            <div class="competitor-medals">
                <span class="medal">🥇 ${comp.medals.gold}</span>
                <span class="medal">🥈 ${comp.medals.silver}</span>
                <span class="medal">🥉 ${comp.medals.bronze}</span>
            </div>
            <div style="font-size: 14px; color: #718096; margin-top: 5px;">
                ${displayRank}
            </div>
        </div>
    `;
    
    card.onclick = () => this.showCompetitorDetail(competitorId);
    return card;
},
                renderFinalistInfo(comp, competitorId) {
    console.log('renderFinalistInfo called');
    console.log('gameConfig.events exists?', !!WCAGuideApp.gameConfig.events);
    console.log('WCAGuideApp exists?', !!WCAGuideApp);
    
    const finalistEvents = [];
    const eventPerformance = [];
    
    if (comp.isFinalist) {
        Object.entries(comp.isFinalist).forEach(([eventId, isFinalist]) => {
            if (isFinalist) {
                console.log('Checking event:', eventId);
                console.log('gameConfig.events at this point:', WCAGuideApp.gameConfig.events);
                const eventName = WCAGuideApp.gameConfig.events[eventId]?.name || eventId;
                // ... rest
                                finalistEvents.push(eventName);
                                
                                // Check for qualifying results
                                // Check for qualifying results
// Check for qualifying results
const results = WCAGuideApp.eventResults[eventId];
                                if (results) {
                                    const compResult = Object.entries(results).find(([name, data]) => 
                                        comp.name.toLowerCase().includes(name.toLowerCase()) || 
                                        name.toLowerCase().includes(comp.name.toLowerCase())
                                    );
                                    
                                    if (compResult) {
                                        const [, data] = compResult;
                                        eventPerformance.push({
                                            event: eventName,
                                            seed: data.seed,
                                            average: data.average,
                                            best: data.best,
                                            achievement: data.achievement
                                        });
                                    }
                                }
                            }
                        });
                    }

                    if (finalistEvents.length === 0) return '';

                    let performanceHtml = '';
                    if (eventPerformance.length > 0) {
                        performanceHtml = eventPerformance.map(perf => {
                            let achievementBadge = '';
                            if (perf.achievement === 'NR') {
                                achievementBadge = ' <span style="background: #f6e05e; color: #744210; padding: 2px 8px; border-radius: 10px; font-size: 12px; font-weight: bold;">National Record!</span>';
                            } else if (perf.achievement === 'PR') {
                                achievementBadge = ' <span style="background: #9ae6b4; color: #22543d; padding: 2px 8px; border-radius: 10px; font-size: 12px; font-weight: bold;">Personal Record!</span>';
                            }
                            
                            return `
                                <div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 10px;">
                                    <strong>${perf.event}</strong>${achievementBadge}<br>
                                    Seed: #${perf.seed} | Average: ${perf.average}s | Best: ${perf.best}s
                                </div>
                            `;
                        }).join('');
                    }

                    // Add fun facts
                    const funFacts = [];
                    if (finalistEvents.length >= 2) {
                        funFacts.push(`🌟 Made finals in ${finalistEvents.length} events!`);
                    }
                    
                    // Check for NR/PR achievements
                    const achievements = eventPerformance.filter(p => p.achievement);
                    if (achievements.length > 0) {
                        const nrCount = achievements.filter(a => a.achievement === 'NR').length;
                        const prCount = achievements.filter(a => a.achievement === 'PR').length;
                        if (nrCount > 0) {
                            funFacts.push(`🏆 Set ${nrCount} National Record${nrCount > 1 ? 's' : ''} in qualifying!`);
                        }
                        if (prCount > 0) {
                            funFacts.push(`⭐ Achieved ${prCount} Personal Best${prCount > 1 ? 's' : ''} in qualifying!`);
                        }
                    }

                    return `
                        <div style="background: #e6fffa; border: 2px solid #4fd1c5; border-radius: 15px; padding: 20px; margin: 20px 0; text-align: left;">
                            <h3 style="color: #234e52; margin-bottom: 15px;">🎯 WCA 2025 Finals</h3>
                            <div style="font-size: 16px; line-height: 1.8;">
                                ${finalistEvents.length > 1 ? 
                                    `Making finals in ${finalistEvents.length} events!<br>` : 
                                    'Qualified for finals in:'}<br>
                           ${Object.entries(comp.isFinalist).map(([eventId, isFinalist]) => {
    if (!isFinalist) return '';
    const eventName = WCAGuideApp.gameConfig.events[eventId]?.name || eventId;
    const qualifying = comp.wca2025Qualifying?.[eventId];
    const finals = comp.wca2025Finals?.[eventId];
    
    let eventInfo = `<div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.9); border-radius: 10px; border-left: 4px solid ${finals?.placement <= 3 ? '#f6e05e' : '#48bb78'};">`;
    
    // Event name with medal if applicable
    eventInfo += `<div style="font-weight: bold; color: #2d3748; margin-bottom: 8px;">`;
    eventInfo += `${WCAGuideApp.gameConfig.events[eventId]?.icon || '🎲'} ${eventName}`;
    if (finals?.placement === 1) eventInfo += ' 🥇';
    else if (finals?.placement === 2) eventInfo += ' 🥈';
    else if (finals?.placement === 3) eventInfo += ' 🥉';
    eventInfo += `</div>`;
    
    // Check for world records
    const hasWR = qualifying?.achievement === 'WR' || finals?.achievement === 'WR';
    const hasNR = qualifying?.achievement === 'NR' || finals?.achievement === 'NR';
    
    if (qualifying) {
        eventInfo += `<div style="font-size: 14px; color: #4a5568; margin-bottom: 4px;">`;
        eventInfo += `<span style="color: #718096;">Qualifying:</span> Seed #${qualifying.seed} | `;
        eventInfo += `${WCAGuideApp.browse.formatTime(qualifying.average)} avg / ${WCAGuideApp.browse.formatTime(qualifying.best)} single`;
        
        if (qualifying.achievement === 'WR') {
            eventInfo += ` <span style="background: #e53e3e; color: white; padding: 2px 8px; border-radius: 10px; font-size: 12px; font-weight: bold; margin-left: 5px;">🌍 WORLD RECORD!</span>`;
        } else if (qualifying.achievement === 'NR') {
            eventInfo += ` <span style="background: #f6e05e; color: #744210; padding: 2px 8px; border-radius: 10px; font-size: 12px; font-weight: bold; margin-left: 5px;">National Record!</span>`;
        }
        eventInfo += `</div>`;
    }
    
    if (finals) {
        eventInfo += `<div style="font-size: 14px; color: #2d3748;">`;
        eventInfo += `<span style="color: #4c51bf; font-weight: bold;">Finals:</span> `;
        eventInfo += `${finals.placement === 1 ? '1st' : finals.placement === 2 ? '2nd' : finals.placement === 3 ? '3rd' : finals.placement + 'th'} place | `;
        eventInfo += `${WCAGuideApp.browse.formatTime(finals.average)} avg / ${WCAGuideApp.browse.formatTime(finals.best)} single`;
        
        if (finals.achievement === 'WR') {
            eventInfo += ` <span style="background: #e53e3e; color: white; padding: 2px 8px; border-radius: 10px; font-size: 12px; font-weight: bold; margin-left: 5px; animation: pulse 2s infinite;">🌍 WORLD RECORD!</span>`;
        } else if (finals.achievement === 'NR') {
            eventInfo += ` <span style="background: #f6e05e; color: #744210; padding: 2px 8px; border-radius: 10px; font-size: 12px; font-weight: bold; margin-left: 5px;">National Record!</span>`;
        }
        eventInfo += `</div>`;
    }
    
    // Special highlight for world records
    if (hasWR) {
        eventInfo = `<div style="animation: glow 2s ease-in-out infinite; border-radius: 10px;">` + eventInfo;
        eventInfo += `</div>`;
    }
    
    eventInfo += `</div>`;
    
    return eventInfo;
}).filter(x => x).join('')}
                            </div>
                            ${performanceHtml ? `
                                <h4 style="color: #234e52; margin-top: 20px; margin-bottom: 10px;">📊 Qualifying Performance</h4>
                                ${performanceHtml}
                            ` : ''}
                            ${funFacts.length > 0 ? `
                                <div style="margin-top: 20px; padding: 15px; background: #fef5e7; border-radius: 10px;">
                                    ${funFacts.join('<br>')}
                                </div>
                            ` : ''}
                        </div>
                    `;
                },
// Add these functions inside the browse object, after the createCompetitorCard function:

showCompetitorDetail(competitorId) {
    const comp = WCAGuideApp.competitors[competitorId];
    if (!comp) return;
    
    WCAGuideApp.navigate('competitorDetail');
    
    const detailDiv = document.getElementById('competitorDetail');
    
    // Build the detail view HTML
    let detailHTML = `
        <div style="text-align: center;">
            <img src="${comp.photoUrl}" 
                 style="width: 200px; height: 200px; border-radius: 20px; object-fit: cover; margin-bottom: 20px; border: 5px solid #e2e8f0;"
                 onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22200%22%3E%3Crect width=%22200%22 height=%22200%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22%3ENo Photo%3C/text%3E%3C/svg%3E'">
            
            <h2 style="font-size: 32px; margin-bottom: 10px;">${comp.name}</h2>
            <div style="font-size: 20px; color: #718096; margin-bottom: 20px;">🌍 ${comp.countryFull || comp.country}</div>
            
            <div style="display: flex; justify-content: center; gap: 20px; margin-bottom: 30px;">
                <div style="text-align: center;">
                    <div style="font-size: 36px;">🥇</div>
                    <div style="font-size: 24px; font-weight: bold;">${comp.medals.gold}</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 36px;">🥈</div>
                    <div style="font-size: 24px; font-weight: bold;">${comp.medals.silver}</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 36px;">🥉</div>
                    <div style="font-size: 24px; font-weight: bold;">${comp.medals.bronze}</div>
                </div>
            </div>
        </div>
        
        <div style="background: #f7fafc; border-radius: 15px; padding: 20px; margin-bottom: 20px;">
            <h3 style="margin-bottom: 15px;">📊 Competition Stats</h3>
            <div style="font-size: 16px; line-height: 1.8;">
                • Competitions: ${comp.competitions}<br>
                • Total Medals: ${comp.medals.total}<br>
                • WCA ID: ${competitorId}
            </div>
        </div>
        
        <div style="background: #f7fafc; border-radius: 15px; padding: 20px; margin-bottom: 20px;">
            <h3 style="margin-bottom: 15px;">🏆 Best Events</h3>
            <div style="font-size: 16px; line-height: 1.8;">
                ${this.renderBestEvents(comp)}
            </div>
        </div>
    `;
    
    // Add finalist info if applicable
    const finalistInfo = this.renderFinalistInfo(comp, competitorId);
    if (finalistInfo) {
        detailHTML += finalistInfo;
    }
    
    // Add fun facts
    detailHTML += `
        <div style="background: #fef5e7; border-radius: 15px; padding: 20px; margin-top: 20px;">
            <h3 style="color: #f39c12; margin-bottom: 15px;">🌟 Fun Facts</h3>
            <div style="font-size: 16px; line-height: 1.8;">
                ${this.generateFunFacts(comp)}
            </div>
        </div>
    `;
    
    detailDiv.innerHTML = detailHTML;
    
    // Track viewed competitor
    if (!WCAGuideApp.userProgress.viewedCompetitors.includes(competitorId)) {
        WCAGuideApp.userProgress.viewedCompetitors.push(competitorId);
        WCAGuideApp.saveProgress();
    }
},

generateFunFacts(comp) {
    const facts = [];
    
    // Medal-based facts
    if (comp.medals.gold > 100) {
        facts.push(`🥇 Over ${Math.floor(comp.medals.gold / 100) * 100} gold medals!`);
    }
    if (comp.medals.total > 500) {
        facts.push(`🏅 ${comp.medals.total} total medals - that's a lot!`);
    }
    
    // Competition facts
    if (comp.competitions > 100) {
        facts.push(`🌍 Competed in ${comp.competitions} competitions!`);
    }
    
    // Ranking facts
    const topRankings = Object.entries(comp.worldRankings || {})
        .filter(([event, ranking]) => ranking.single <= 10)
        .length;
    if (topRankings > 0) {
        facts.push(`🌟 Top 10 in the world in ${topRankings} event${topRankings > 1 ? 's' : ''}!`);
    }
    
    // If no facts generated, add a default
    if (facts.length === 0) {
        facts.push(`🎯 An awesome cuber from ${comp.country}!`);
    }
    
    return facts.join('<br>');
},

prevEvent() {
    if (this.mode === 'world') {
        this.currentEventIndex = (this.currentEventIndex - 1 + this.eventOrder.length) % this.eventOrder.length;
    } else {
        // For finalists, find previous event with finalists
        let attempts = 0;
        do {
            this.currentEventIndex = (this.currentEventIndex - 1 + this.eventOrder.length) % this.eventOrder.length;
            const eventId = this.eventOrder[this.currentEventIndex];
            const hasFinalists = Object.values(WCAGuideApp.competitors)
                .some(comp => comp.isFinalist && comp.isFinalist[eventId]);
            if (hasFinalists) break;
            attempts++;
        } while (attempts < this.eventOrder.length);
    }
    
    this.showCurrentEvent();
},

nextEvent() {
    if (this.mode === 'world') {
        this.currentEventIndex = (this.currentEventIndex + 1) % this.eventOrder.length;
    } else {
        // For finalists, find next event with finalists
        let attempts = 0;
        do {
            this.currentEventIndex = (this.currentEventIndex + 1) % this.eventOrder.length;
            const eventId = this.eventOrder[this.currentEventIndex];
            const hasFinalists = Object.values(WCAGuideApp.competitors)
                .some(comp => comp.isFinalist && comp.isFinalist[eventId]);
            if (hasFinalists) break;
            attempts++;
        } while (attempts < this.eventOrder.length);
    }
    
    this.showCurrentEvent();
},
                renderBestEvents(comp) {
                    const topEvents = Object.entries(comp.worldRankings)
                        .sort((a, b) => a[1].single - b[1].single)
                        .slice(0, 3);

                    return topEvents.map(([eventId, ranking]) => {
                        const eventName = WCAGuideApp.gameConfig.events[eventId]?.name || eventId;
                        const time = this.formatTime(ranking.singleTime);
                        return `• ${eventName}: ${time} (#${ranking.single} World)<br>`;
                    }).join('');
                },
     formatTime(centiseconds) {
                    const minutes = Math.floor(centiseconds / 6000);
                    const seconds = ((centiseconds % 6000) / 100).toFixed(2);
                    return minutes > 0 ? `${minutes}:${seconds.padStart(5, '0')}` : `${seconds}s`;
                }
            },

            // Predictions module
            predictions: {
                currentEvent: null,
                currentSlot: null,
                selections: {},

                init() {
                    this.renderEventList();
                },

                renderEventList() {
                    const list = document.getElementById('predictionEventList');
                    list.innerHTML = '';

                    Object.entries(WCAGuideApp.gameConfig.events).forEach(([eventId, event]) => {
                        const card = document.createElement('div');
                        
                        // Check if we have any finalists for this event
                        const hasFinalists = Object.values(WCAGuideApp.competitors)
                            .some(comp => comp.isFinalist && comp.isFinalist[eventId]);
                        
                        card.style.cssText = `
                            background: #f7fafc;
                            border: 2px solid #e2e8f0;
                            border-radius: 15px;
                            padding: 20px;
                            margin-bottom: 15px;
                            cursor: ${hasFinalists ? 'pointer' : 'default'};
                            opacity: ${hasFinalists ? '1' : '0.6'};
                        `;

                        let statusText = '';
                        let statusColor = '#718096';

                        if (hasFinalists) {
                            statusText = 'Make Predictions →';
                            statusColor = '#5a67d8';
                            card.onclick = () => this.startPredictions(eventId);
                        } else {
                            statusText = 'No finalists yet';
                            statusColor = '#718096';
                        }

                        card.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <span style="font-size: 24px; margin-right: 10px;">${event.icon}</span>
                                    <span style="font-size: 18px; font-weight: bold;">${event.name}</span>
                                </div>
                                <div style="color: ${statusColor}; font-weight: bold;">${statusText}</div>
                            </div>
                        `;

                        list.appendChild(card);
                    });
                },

                startPredictions(eventId) {
                    this.currentEvent = eventId;
                    this.selections[eventId] = WCAGuideApp.userProgress.predictions[eventId] || {};
                    
                    WCAGuideApp.navigate('makePredictions');
                    document.getElementById('makePredictionsTitle').textContent = 
                        `My ${WCAGuideApp.gameConfig.events[eventId].name} Predictions`;
                    
                    this.renderPredictionSlots();
                },

                renderPredictionSlots() {
                    const container = document.getElementById('predictionSlots');
                    container.innerHTML = '';

                    const ranks = ['1st', '2nd', '3rd', '4th', '5th'];
                    const emojis = ['🥇', '🥈', '🥉', '4️⃣', '5️⃣'];

                    ranks.forEach((rank, index) => {
                        const slot = document.createElement('div');
                        slot.className = 'prediction-slot';
                        
                        const selection = this.selections[this.currentEvent]?.[rank];
                        if (selection) {
                            slot.classList.add('filled');
                            const comp = WCAGuideApp.competitors[selection];
                            slot.innerHTML = `
                                <div class="rank">${emojis[index]}</div>
                                <div class="selected-name">${comp?.name || 'Unknown'}</div>
                                <button class="clear-btn" onclick="WCAGuideApp.predictions.clearSlot('${rank}')">×</button>
                            `;
                        } else {
                            slot.innerHTML = `
                                <div class="rank">${emojis[index]}</div>
                                <div class="placeholder">${index < 3 ? 'Tap to pick' : '+ Add (optional)'}</div>
                            `;
                        }
                        
                        slot.onclick = (e) => {
                            if (!e.target.classList.contains('clear-btn')) {
                                this.selectCompetitor(rank);
                            }
                        };
                        
                        container.appendChild(slot);
                    });
                },

              selectCompetitor(slot) {
    this.currentSlot = slot;
    WCAGuideApp.navigate('competitorSelect');
    document.getElementById('competitorSelectTitle').textContent = `Pick your ${slot} place prediction`;
    
    const grid = document.getElementById('competitorSelectGrid');
    grid.innerHTML = '';

    // Get ONLY finalists for this event, sorted by seed
    const finalists = Object.entries(WCAGuideApp.competitors)
        .filter(([id, comp]) => comp.isFinalist && comp.isFinalist[this.currentEvent] === true)
        .sort((a, b) => {
            const seedA = a[1].wca2025Qualifying?.[this.currentEvent]?.seed || 999;
            const seedB = b[1].wca2025Qualifying?.[this.currentEvent]?.seed || 999;
            return seedA - seedB;
        })
        .slice(0, 20);

    if (finalists.length === 0) {
        grid.innerHTML = '<div style="text-align: center; padding: 50px; color: #718096;">Loading finalists...</div>';
        return;
    }

    // Change grid to show more details
    grid.style.cssText = `
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 15px;
        margin: 20px 0;
    `;

    finalists.forEach(([id, comp]) => {
        const card = document.createElement('div');
        card.className = 'competitor-select-card';
        
        // Check if already selected
        const alreadySelected = Object.values(this.selections[this.currentEvent] || {}).includes(id);
        if (alreadySelected) {
            card.classList.add('selected');
        }

        // Get rankings
        const worldRank = comp.worldRankings[this.currentEvent]?.single || 'N/A';
        const competitionSeed = comp.wca2025Qualifying?.[this.currentEvent]?.seed || 'N/A';
        const hasTime = comp.worldRankings[this.currentEvent]?.singleTime;
        const bestTime = hasTime ? WCAGuideApp.browse.formatTime(comp.worldRankings[this.currentEvent].singleTime) : 'N/A';

        card.style.cssText = `
            background: ${alreadySelected ? '#e2e8f0' : '#f7fafc'};
            border: 2px solid ${alreadySelected ? '#a0aec0' : '#e2e8f0'};
            border-radius: 15px;
            padding: 15px 10px;
            text-align: center;
            cursor: ${alreadySelected ? 'default' : 'pointer'};
            transition: all 0.2s;
            opacity: ${alreadySelected ? '0.6' : '1'};
            position: relative;
        `;

        card.innerHTML = `
            <img src="${comp.photoThumbUrl}" 
                 style="width: 60px; height: 60px; border-radius: 50%; margin-bottom: 8px;"
                 onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2260%22 height=%2260%22%3E%3Crect width=%2260%22 height=%2260%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22 font-size=%2210%22%3ENo Photo%3C/text%3E%3C/svg%3E'">
            <div class="name" style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">${comp.name}</div>
            <div style="font-size: 12px; color: #718096; margin-bottom: 3px;">🌍 ${comp.country}</div>
            <div style="font-size: 12px; color: #e53e3e; font-weight: bold;">🏁 Seed #${competitionSeed}</div>
            <div style="font-size: 11px; color: #4a5568;">🌍 World #${worldRank}</div>
            <div style="font-size: 11px; color: #718096;">${bestTime}</div>
            <div style="font-size: 11px; color: #718096; margin-top: 5px;">
                🥇${comp.medals.gold} 🥈${comp.medals.silver} 🥉${comp.medals.bronze}
            </div>
            ${alreadySelected ? '<div style="font-size: 11px; color: #e53e3e; margin-top: 5px; font-weight: bold;">Already picked!</div>' : ''}
        `;

        // Create info button after innerHTML
        const infoBtn = document.createElement('button');
        infoBtn.style.cssText = 'position: absolute; top: 5px; right: 5px; background: #5a67d8; color: white; border: none; width: 28px; height: 28px; border-radius: 50%; font-size: 14px; cursor: pointer; z-index: 10; display: flex; align-items: center; justify-content: center;';
        infoBtn.innerHTML = 'ℹ️';
        infoBtn.onclick = (e) => {
            e.stopPropagation();
            WCAGuideApp.browse.showCompetitorDetail(id);
        };
        card.appendChild(infoBtn);

        if (!alreadySelected) {
            card.onmouseover = () => {
                if (!alreadySelected) {
                    card.style.transform = 'scale(1.05)';
                    card.style.boxShadow = '0 4px 15px rgba(0,0,0,0.1)';
                }
            };
            card.onmouseout = () => {
                card.style.transform = 'scale(1)';
                card.style.boxShadow = 'none';
            };
            card.onclick = () => this.confirmSelection(id);
        }

        grid.appendChild(card);
    });
},
                confirmSelection(competitorId) {
                    // Check if already selected in a different slot
                    const existingSlot = Object.entries(this.selections[this.currentEvent] || {})
                        .find(([slot, id]) => id === competitorId);
                    
                    if (existingSlot && existingSlot[0] !== this.currentSlot) {
                        alert(`You already picked ${WCAGuideApp.competitors[competitorId].name} for ${existingSlot[0]} place!`);
                        return;
                    }
                    
                    if (!this.selections[this.currentEvent]) {
                        this.selections[this.currentEvent] = {};
                    }
                    
                    this.selections[this.currentEvent][this.currentSlot] = competitorId;
                    
                    // Go back to predictions screen WITHOUT adding to history
                    WCAGuideApp.goBack();
                    this.renderPredictionSlots();
                },

                clearSlot(slot) {
                    delete this.selections[this.currentEvent][slot];
                    this.renderPredictionSlots();
                },

                clearAll() {
                    this.selections[this.currentEvent] = {};
                    this.renderPredictionSlots();
                },

                savePredictions() {
                    WCAGuideApp.userProgress.predictions[this.currentEvent] = this.selections[this.currentEvent];
                    WCAGuideApp.saveProgress();
                    
                    alert('Predictions saved! Good luck! 🍀');
                    WCAGuideApp.navigate('predictions');
                }
            },

            // Results module
            results: {
                init() {
                    this.renderEventList();
                },

                renderEventList() {
                    const list = document.getElementById('resultsEventList');
                    list.innerHTML = '';

                    Object.entries(WCAGuideApp.gameConfig.events).forEach(([eventId, event]) => {
                        // Check if we have any results for this event
                        const hasResults = WCAGuideApp.gameConfig.actualResults?.[eventId] && 
                                         Object.values(WCAGuideApp.gameConfig.actualResults[eventId]).some(id => id !== null);
                        const hasPredictions = WCAGuideApp.userProgress.predictions[eventId] && 
                                             Object.keys(WCAGuideApp.userProgress.predictions[eventId]).length > 0;
                        
                        if (!hasResults) return; // Skip if no results yet

                        const card = document.createElement('div');
                        card.style.cssText = `
                            background: #f7fafc;
                            border: 2px solid #e2e8f0;
                            border-radius: 15px;
                            padding: 20px;
                            margin-bottom: 15px;
                            cursor: pointer;
                        `;

                        card.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <span style="font-size: 24px; margin-right: 10px;">${event.icon}</span>
                                    <span style="font-size: 18px; font-weight: bold;">${event.name}</span>
                                    <div style="font-size: 14px; color: #718096; margin-top: 5px;">
                                        ${hasPredictions ? 'See how you did!' : 'View results'}
                                    </div>
                                </div>
                                <button class="action-btn" style="padding: 10px 20px;">
                                    View →
                                </button>
                            </div>
                        `;

                        card.onclick = () => this.showResults(eventId);
                        list.appendChild(card);
                    });

                    if (list.innerHTML === '') {
                        list.innerHTML = '<div style="text-align: center; color: #718096; padding: 50px;">No results posted yet!</div>';
                    }
                },

               showResults(eventId) {
    WCAGuideApp.navigate('enterResults');
    document.getElementById('enterResultsTitle').textContent = 
        `${WCAGuideApp.gameConfig.events[eventId].name} Results`;
    
    const content = document.getElementById('enterResultsContent');
    content.innerHTML = '';

    const predictions = WCAGuideApp.userProgress.predictions[eventId] || {};
    const actualResults = WCAGuideApp.gameConfig.actualResults[eventId];

    // First section: Show how predictions did (if any)
    if (Object.keys(predictions).length > 0) {
        const predSection = document.createElement('div');
        predSection.innerHTML = '<h3 style="margin-bottom: 15px;">Your Predictions:</h3>';
        
        Object.entries(predictions).forEach(([predictedRank, competitorId]) => {
            const comp = WCAGuideApp.competitors[competitorId];
            if (!comp) return; // Skip if competitor not found
            
            // Find actual position
            let actualPosition = null;
            Object.entries(actualResults).forEach(([rank, actualId]) => {
                if (actualId === competitorId) {
                    actualPosition = rank;
                }
            });

            const resultCard = document.createElement('div');
            resultCard.style.cssText = `
                background: #f7fafc;
                border: 2px solid ${actualPosition ? '#48bb78' : '#e2e8f0'};
                border-radius: 15px;
                padding: 15px;
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                position: relative;
            `;

            resultCard.innerHTML = `
                <div style="display: flex; align-items: center;">
                    <img src="${comp.photoThumbUrl}" 
                         style="width: 50px; height: 50px; border-radius: 50%; margin-right: 15px;"
                         onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2250%22 height=%2250%22%3E%3Crect width=%2250%22 height=%2250%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22 font-size=%2210%22%3ENo Photo%3C/text%3E%3C/svg%3E'">
                    <div>
                        <div style="font-weight: bold;">${comp.name}</div>
                        <div style="font-size: 14px; color: #718096;">
                            Predicted: ${predictedRank}
                        </div>
                    </div>
                </div>
                <div style="text-align: right;">
                    ${actualPosition ? 
                        `<div style="color: #48bb78; font-weight: bold;">✓ ${actualPosition}</div>` : 
                        '<div style="color: #e53e3e;">Not in top 5</div>'
                    }
                </div>
            `;

            // Add info button
            const infoBtn = document.createElement('button');
            infoBtn.style.cssText = 'position: absolute; top: 10px; right: 10px; background: #5a67d8; color: white; border: none; width: 28px; height: 28px; border-radius: 50%; font-size: 14px; cursor: pointer; z-index: 10; display: flex; align-items: center; justify-content: center;';
            infoBtn.innerHTML = 'ℹ️';
            infoBtn.onclick = (e) => {
                e.stopPropagation();
                WCAGuideApp.browse.showCompetitorDetail(competitorId);
            };
            resultCard.appendChild(infoBtn);

            predSection.appendChild(resultCard);
        });
        
        content.appendChild(predSection);
        
        // Divider
        content.innerHTML += '<hr style="margin: 30px 0; border-color: #e2e8f0;">';
    }

    // Second section: Actual results
    const resultsSection = document.createElement('div');
    resultsSection.innerHTML = '<h3 style="margin-bottom: 15px;">Actual Results:</h3>';

    const getMedal = (rank) => {
        if (rank.startsWith('1st')) return '🥇';
        if (rank.startsWith('2nd')) return '🥈';
        if (rank.startsWith('3rd')) return '🥉';
        if (rank.startsWith('4th')) return '4️⃣';
        if (rank.startsWith('5th')) return '5️⃣';
        return '🏆';
    };
    
    Object.entries(actualResults).forEach(([rank, competitorId]) => {
        if (!competitorId) return; // Skip null entries
        
        const comp = WCAGuideApp.competitors[competitorId];
        if (!comp) return; // Skip if competitor not found
        
        const winnerCard = document.createElement('div');
        winnerCard.style.cssText = `
            background: linear-gradient(135deg, #f9d976 0%, #f39f86 100%);
            border: 2px solid #f39f86;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            position: relative;
        `;

        winnerCard.innerHTML = `
            <div style="font-size: 30px; margin-right: 15px;">${getMedal(rank)}</div>
            <img src="${comp.photoThumbUrl}" 
                 style="width: 60px; height: 60px; border-radius: 50%; margin-right: 15px;"
                 onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2260%22 height=%2260%22%3E%3Crect width=%2260%22 height=%2260%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22 font-size=%2212%22%3ENo Photo%3C/text%3E%3C/svg%3E'">
            <div style="flex: 1;">
                <div style="font-weight: bold; font-size: 18px;">${comp.name}</div>
                <div style="font-size: 14px;">🌍 ${comp.country}</div>
            </div>
        `;

        // Add info button
        const infoBtnWinner = document.createElement('button');
        infoBtnWinner.style.cssText = 'position: absolute; top: 15px; right: 15px; background: #5a67d8; color: white; border: none; width: 28px; height: 28px; border-radius: 50%; font-size: 14px; cursor: pointer; z-index: 10; display: flex; align-items: center; justify-content: center;';
        infoBtnWinner.innerHTML = 'ℹ️';
        infoBtnWinner.onclick = (e) => {
            e.stopPropagation();
            WCAGuideApp.browse.showCompetitorDetail(competitorId);
        };
        winnerCard.appendChild(infoBtnWinner);

        resultsSection.appendChild(winnerCard);
    });

    content.appendChild(resultsSection);
}
                },
            // Games module
            games: {
                currentGame: null,
                currentDifficulty: null,
                currentQuestions: [],
                currentQuestionIndex: 0,
                score: 0,
                usedQuestionIds: new Set(),
                
                init() {
                    // Initialize game system
                },

                selectGame(gameType) {
                    this.currentGame = gameType;
                    this.usedQuestionIds.clear(); // Reset used questions
                    WCAGuideApp.navigate('gameDifficulty');
                    document.getElementById('gameDifficultyTitle').textContent = 
                        `${this.getGameName(gameType)} - Choose Difficulty`;
                },

                getGameName(gameType) {
                    const names = {
                        faces: 'Faces Quiz',
                        countries: 'Countries Match',
                        speed: 'Speed Stats',
                        facts: 'Cube Facts',
                        mixed: 'Mix It Up!'
                    };
                    return names[gameType] || gameType;
                },

                startGame(difficulty) {
                    this.currentDifficulty = difficulty;
                    this.currentQuestionIndex = 0;
                    this.score = 0;
                    
                    // Generate questions
                    this.currentQuestions = this.generateQuestions(this.currentGame, difficulty, 10);
                    
                    WCAGuideApp.navigate('gamePlay');
                    this.showQuestion();
                },

                generateQuestions(gameType, difficulty, count) {
                    const questions = [];
                    
                    for (let i = 0; i < count; i++) {
                        let question;
                        
                        switch (gameType) {
                            case 'faces':
                                question = this.generatePhotoQuestion(difficulty);
                                break;
                            case 'countries':
                                question = this.generateCountryQuestion(difficulty);
                                break;
                            case 'speed':
                                question = this.generateSpeedQuestion(difficulty);
                                break;
                            case 'facts':
                                question = this.generateFactQuestion(difficulty);
                                break;
                            case 'mixed':
                                // Rotate through different types including achievement questions
                                const types = ['faces', 'countries', 'speed', 'facts', 'achievements'];
                                const type = types[i % types.length];
                                if (type === 'achievements') {
                                    question = this.generateAchievementQuestion(difficulty);
                                } else {
                                    question = this.generateQuestions(type, difficulty, 1)[0];
                                }
                                break;
                        }
                        
                        if (question) questions.push(question);
                    }
                    
                    return questions;
                },

                generatePhotoQuestion(difficulty) {
                    const competitors = Object.values(WCAGuideApp.competitors)
                        .filter(c => c.difficulty === difficulty || difficulty === 'mixed');
                    
                    const correct = competitors[Math.floor(Math.random() * competitors.length)];
                    const wrongAnswers = competitors
                        .filter(c => c.name !== correct.name)
                        .sort(() => Math.random() - 0.5)
                        .slice(0, 3)
                        .map(c => c.name);
                    
                    return {
                        type: 'photo',
                        question: 'Who is this competitor?',
                        photoUrl: correct.photoUrl,
                        correctAnswer: correct.name,
                        options: this.shuffleArray([correct.name, ...wrongAnswers])
                    };
                },

                generateCountryQuestion(difficulty) {
                    const competitors = Object.values(WCAGuideApp.competitors)
                        .filter(c => c.difficulty === difficulty || difficulty === 'mixed');
                    
                    const correct = competitors[Math.floor(Math.random() * competitors.length)];
                    const allCountries = [...new Set(Object.values(WCAGuideApp.competitors).map(c => c.country))];
                    const wrongCountries = allCountries
                        .filter(country => country !== correct.country)
                        .sort(() => Math.random() - 0.5)
                        .slice(0, 3);
                    
                    return {
                        type: 'country',
                        question: `Which country is ${correct.name} from?`,
                        correctAnswer: correct.country,
                        options: this.shuffleArray([correct.country, ...wrongCountries]),
                        competitorPhoto: correct.photoThumbUrl
                    };
                },

                generateSpeedQuestion(difficulty) {
                    const competitors = Object.values(WCAGuideApp.competitors)
                        .filter(c => c.worldRankings['333']);
                    
                    let comp1, comp2;
                    do {
                        comp1 = competitors[Math.floor(Math.random() * competitors.length)];
                        comp2 = competitors[Math.floor(Math.random() * competitors.length)];
                    } while (comp1.name === comp2.name);
                    
                    const time1 = comp1.worldRankings['333'].singleTime;
                    const time2 = comp2.worldRankings['333'].singleTime;
                    
                    return {
                        type: 'comparison',
                        question: 'Who has a faster 3x3x3 single time?',
                        option1: {
                            name: comp1.name,
                            photo: comp1.photoThumbUrl,
                            time: WCAGuideApp.browse.formatTime(time1)
                        },
                        option2: {
                            name: comp2.name,
                            photo: comp2.photoThumbUrl,
                            time: WCAGuideApp.browse.formatTime(time2)
                        },
                        correctAnswer: time1 < time2 ? comp1.name : comp2.name,
                        options: [comp1.name, comp2.name]
                    };
                },

                generateFactQuestion(difficulty) {
                    const factPool = WCAGuideApp.facts.general[difficulty];
                    
                    // Fallback to easy if requested difficulty has no questions
                    if (!factPool || factPool.length === 0) {
                        const easyPool = WCAGuideApp.facts.general.easy;
                        if (!easyPool || easyPool.length === 0) {
                            // Return a default question if no facts are loaded
                            return {
                                id: "default_001",
                                question: "How many stickers are on a 3x3x3 cube?",
                                answer: "54",
                                options: ["36", "48", "54", "60"]
                            };
                        }
                        return easyPool[Math.floor(Math.random() * easyPool.length)];
                    }
                    
                    // Try to find an unused question
                    let attempts = 0;
                    let question = null;
                    
                    while (attempts < factPool.length) {
                        const index = Math.floor(Math.random() * factPool.length);
                        question = factPool[index];
                        
                        if (!this.usedQuestionIds.has(question.id)) {
                            this.usedQuestionIds.add(question.id);
                            return question;
                        }
                        attempts++;
                    }
                    
                    // If all questions used, clear and start over
                    this.usedQuestionIds.clear();
                    question = factPool[Math.floor(Math.random() * factPool.length)];
                    if (question && question.id) {
                        this.usedQuestionIds.add(question.id);
                    }
                    return question;
                },

                generateAchievementQuestion(difficulty) {
                    // Questions about WCA 2025 achievements
                    const achievements = [];
                    
                    // Find all NR/PR achievements
                    Object.entries(WCAGuideApp.eventResults).forEach(([eventId, results]) => {
                        Object.entries(results).forEach(([name, data]) => {
                            if (data.achievement) {
                                achievements.push({
                                    name: name,
                                    event: WCAGuideApp.gameConfig.events[eventId]?.name || eventId,
                                    achievement: data.achievement,
                                    time: data.best || data.average
                                });
                            }
                        });
                    });
                    
                    if (achievements.length === 0) {
                        return this.generateFactQuestion(difficulty);
                    }
                    
                    // Generate question based on achievements
                    const questionTypes = ['who_got_nr', 'who_got_pr', 'how_many_nr', 'multiple_finals'];
                    const type = questionTypes[Math.floor(Math.random() * questionTypes.length)];
                    
                    switch (type) {
                        case 'who_got_nr':
                            const nrAchievements = achievements.filter(a => a.achievement === 'NR');
                            if (nrAchievements.length > 0) {
                                const correct = nrAchievements[Math.floor(Math.random() * nrAchievements.length)];
                                const options = this.getRandomNames(3, correct.name);
                                return {
                                    type: 'achievement',
                                    question: `Who set a National Record in ${correct.event} qualifying?`,
                                    correctAnswer: correct.name,
                                    options: this.shuffleArray([correct.name, ...options])
                                };
                            }
                            break;
                            
                        case 'how_many_nr':
                            const nrCount = achievements.filter(a => a.achievement === 'NR').length;
                            return {
                                type: 'achievement',
                                question: 'How many National Records were set in qualifying rounds so far?',
                                correctAnswer: nrCount.toString(),
                                options: this.shuffleArray([nrCount.toString(), (nrCount-1).toString(), (nrCount+1).toString(), (nrCount+2).toString()])
                            };
                            
                        case 'multiple_finals':
                            const multiFinalists = Object.values(WCAGuideApp.competitors)
                                .filter(comp => {
                                    const finalsCount = Object.values(comp.isFinalist || {}).filter(v => v).length;
                                    return finalsCount >= 2;
                                });
                            if (multiFinalists.length > 0) {
                                const correct = multiFinalists[Math.floor(Math.random() * multiFinalists.length)];
                                const finalsCount = Object.values(correct.isFinalist).filter(v => v).length;
                                return {
                                    type: 'achievement',
                                    question: `How many events did ${correct.name} make finals in?`,
                                    correctAnswer: finalsCount.toString(),
                                    options: ['1', '2', '3', '4']
                                };
                            }
                            break;
                    }
                    
                    // Fallback to regular fact
                    return this.generateFactQuestion(difficulty);
                },

                getRandomNames(count, exclude) {
                    const allNames = [];
                    Object.values(WCAGuideApp.competitors).forEach(comp => {
                        if (comp.name !== exclude) {
                            allNames.push(comp.name);
                        }
                    });
                    
                    const selected = [];
                    for (let i = 0; i < count && i < allNames.length; i++) {
                        const index = Math.floor(Math.random() * allNames.length);
                        selected.push(allNames[index]);
                        allNames.splice(index, 1);
                    }
                    
                    return selected;
                },

                shuffleArray(array) {
                    const arr = [...array];
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    return arr;
                },

                showQuestion() {
                    const question = this.currentQuestions[this.currentQuestionIndex];
                    
                    // Update header
                    document.getElementById('questionCounter').textContent = 
                        `Question ${this.currentQuestionIndex + 1} of ${this.currentQuestions.length}`;
                    document.getElementById('gameScore').textContent = `Score: ${this.score}⭐`;
                    
                    // Update progress bar
                    const progress = ((this.currentQuestionIndex + 1) / this.currentQuestions.length) * 100;
                    document.getElementById('progressFill').style.width = progress + '%';
                    
                    // Render question
                    const questionBox = document.getElementById('questionBox');
                    const optionsGrid = document.getElementById('optionsGrid');
                    
                    questionBox.innerHTML = `<div class="question-text">${question.question}</div>`;
                    
                    if (question.photoUrl) {
                        questionBox.innerHTML += `
                            <img src="${question.photoUrl}" class="question-photo" 
                                 onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22150%22 height=%22150%22%3E%3Crect width=%22150%22 height=%22150%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22%3ENo Photo%3C/text%3E%3C/svg%3E'"">
                        `;
                    } else if (question.competitorPhoto) {
                        questionBox.innerHTML += `
                            <img src="${question.competitorPhoto}" class="question-photo" 
                                 onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22150%22 height=%22150%22%3E%3Crect width=%22150%22 height=%22150%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22%3ENo Photo%3C/text%3E%3C/svg%3E'""
                                 style="width: 100px; height: 100px;">
                        `;
                    }
                    
                    // Render options
                    optionsGrid.innerHTML = '';
                    
                    if (question.type === 'comparison') {
                        // Special layout for comparison questions - DON'T show times initially
                        const option1 = document.createElement('button');
                        option1.className = 'option-btn';
                        option1.innerHTML = `
                            <img src="${question.option1.photo}" style="width: 50px; height: 50px; border-radius: 50%; margin-bottom: 10px;"
                                 onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2250%22 height=%2250%22%3E%3Crect width=%2250%22 height=%2250%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22 font-size=%2210%22%3ENo Photo%3C/text%3E%3C/svg%3E'"">
                            <div>${question.option1.name}</div>
                            <div class="time-reveal" style="font-size: 14px; color: #718096; opacity: 0; transition: opacity 0.5s;">
                                ${question.option1.time}
                            </div>
                        `;
                        option1.onclick = () => this.checkAnswer(question.option1.name, question.correctAnswer, true);
                        
                        const option2 = document.createElement('button');
                        option2.className = 'option-btn';
                        option2.innerHTML = `
                            <img src="${question.option2.photo}" style="width: 50px; height: 50px; border-radius: 50%; margin-bottom: 10px;"
                                 onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2250%22 height=%2250%22%3E%3Crect width=%2250%22 height=%2250%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22 font-size=%2210%22%3ENo Photo%3C/text%3E%3C/svg%3E'"">
                            <div>${question.option2.name}</div>
                            <div class="time-reveal" style="font-size: 14px; color: #718096; opacity: 0; transition: opacity 0.5s;">
                                ${question.option2.time}
                            </div>
                        `;
                        option2.onclick = () => this.checkAnswer(question.option2.name, question.correctAnswer, true);
                        
                        optionsGrid.appendChild(option1);
                        optionsGrid.appendChild(option2);
                    } else {
                        // Regular multiple choice
                        question.options.forEach((option, index) => {
                            const btn = document.createElement('button');
                            btn.className = 'option-btn';
                            btn.textContent = `${String.fromCharCode(65 + index)}) ${option}`;
                            btn.onclick = () => this.checkAnswer(option, question.correctAnswer || question.answer);
                            optionsGrid.appendChild(btn);
                        });
                    }
                },

                checkAnswer(selected, correct, isComparison = false) {
                    const buttons = document.querySelectorAll('.option-btn');
                    buttons.forEach(btn => {
                        btn.onclick = null; // Disable clicking
                        
                        const btnText = btn.textContent || btn.innerText;
                        const nameDiv = btn.querySelector('div');
                        const isThisButton = nameDiv ? nameDiv.textContent === selected : btnText.includes(selected);
                        const isCorrectButton = nameDiv ? nameDiv.textContent === correct : btnText.includes(correct);
                        
                        if (isCorrectButton) {
                            btn.classList.add('correct');
                        } else if (isThisButton && selected !== correct) {
                            btn.classList.add('incorrect');
                        }
                        
                        // Reveal times for comparison questions
                        if (isComparison) {
                            const timeReveal = btn.querySelector('.time-reveal');
                            if (timeReveal) {
                                timeReveal.style.opacity = '1';
                            }
                        }
                    });
                    
                    if (selected === correct) {
                        this.score++;
                    }
                    
                    // Next question after delay
                    setTimeout(() => {
                        this.currentQuestionIndex++;
                        if (this.currentQuestionIndex < this.currentQuestions.length) {
                            this.showQuestion();
                        } else {
                            this.endGame();
                        }
                    }, isComparison ? 2000 : 1500); // Slightly longer pause for comparison to see times
                },

                endGame() {
                    // Update game scores
                    const gameKey = this.currentGame;
                    if (!WCAGuideApp.userProgress.gameScores[gameKey]) {
                        WCAGuideApp.userProgress.gameScores[gameKey] = { highScore: 0, totalGames: 0 };
                    }
                    
                    const gameData = WCAGuideApp.userProgress.gameScores[gameKey];
                    gameData.totalGames++;
                    gameData.highScore = Math.min(gameData.highScore + this.score, 100);
                    
                    WCAGuideApp.saveProgress();
                    
                    // Show results
                    WCAGuideApp.navigate('gameResults');
                    document.getElementById('finalScore').textContent = `${this.score}/${this.currentQuestions.length}`;
                    
                    let message = '';
                    const percentage = (this.score / this.currentQuestions.length) * 100;
                    if (percentage === 100) {
                        message = '🌟 PERFECT! You\'re amazing!';
                    } else if (percentage >= 80) {
                        message = '🎉 Excellent work!';
                    } else if (percentage >= 60) {
                        message = '👍 Good job!';
                    } else if (percentage >= 40) {
                        message = '💪 Keep practicing!';
                    } else {
                        message = '🌈 Nice try! Play again!';
                    }
                    
                    document.getElementById('resultMessage').textContent = message;
                }
            },

            // Scores module
            scores: {
                init() {
                    this.renderScores();
                },

                renderScores() {
    console.log('=== SCORES DEBUG ===');
    console.log('1. userProgress.gameScores:', WCAGuideApp.userProgress.gameScores);
    
    const saved = localStorage.getItem('wca2025_liam');
    console.log('2. Raw localStorage:', saved);
    
    if (saved) {
        const parsed = JSON.parse(saved);
        console.log('3. Parsed gameScores:', parsed.gameScores);
    }
    
    const list = document.getElementById('scoresList');
    console.log('4. scoresList element exists:', !!list);
    
    // Continue with your original renderScores code...
    list.innerHTML = '';
    // ... rest of the function

                    const games = [
                        { key: 'faces', name: 'Faces Quiz', icon: '😊' },
                        { key: 'countries', name: 'Countries Match', icon: '🌍' },
                        { key: 'speed', name: 'Speed Stats', icon: '🏃' },
                        { key: 'facts', name: 'Cube Facts', icon: '📚' },
                        { key: 'mixed', name: 'Mix It Up!', icon: '❓' }
                    ];

                    games.forEach(game => {
                        const data = WCAGuideApp.userProgress.gameScores[game.key] || { highScore: 0, totalGames: 0 };
                        
                        const card = document.createElement('div');
                        card.style.cssText = `
                            background: #f7fafc;
                            border: 2px solid #e2e8f0;
                            border-radius: 15px;
                            padding: 20px;
                            margin-bottom: 15px;
                        `;

                        card.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <span style="font-size: 24px; margin-right: 10px;">${game.icon}</span>
                                    <span style="font-size: 18px; font-weight: bold;">${game.name}</span>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 24px; font-weight: bold; color: #48bb78;">
                                        ${data.highScore}/100 ⭐
                                    </div>
                                    <div style="font-size: 14px; color: #718096;">
                                        ${data.totalGames} game${data.totalGames !== 1 ? 's' : ''} played
                                    </div>
                                </div>
                            </div>
                        `;

                        list.appendChild(card);
                    });
                }
            },

            // Storage module
            storage: {
                qrCode: null,
                currentSaveCode: null,
                
                init() {
                    this.generateSaveCode();
                },

                generateSaveCode() {
                    // Create compressed version of save data
                    const saveData = {
                        v: 1, // version
                        p: WCAGuideApp.userProgress.predictions,
                        r: WCAGuideApp.userProgress.results,
                        g: WCAGuideApp.userProgress.gameScores
                    };
                    
                    // Convert to base64
                    const jsonStr = JSON.stringify(saveData);
                    const compressed = btoa(jsonStr);
                    
                    // Generate short manual code (first 8 chars of hash)
                    let hash = 0;
                    for (let i = 0; i < jsonStr.length; i++) {
                        hash = ((hash << 5) - hash) + jsonStr.charCodeAt(i);
                        hash = hash & hash;
                    }
                    const shortCode = 'WCA' + Math.abs(hash).toString(36).substring(0, 5).toUpperCase();
                    
                    this.currentSaveCode = shortCode;
                    document.getElementById('saveCode').textContent = shortCode;
                    
                    // Store mapping in localStorage (in real app, this would be server-side)
                    const allCodes = JSON.parse(localStorage.getItem('wca2025_codes') || '{}');
                    allCodes[shortCode] = compressed;
                    localStorage.setItem('wca2025_codes', JSON.stringify(allCodes));
                    
                    // Generate QR code if library is loaded
                    if (typeof QRCode !== 'undefined') {
                        const qrContainer = document.getElementById('qrcode');
                        if (qrContainer) {
                            qrContainer.innerHTML = ''; // Clear existing
                            this.qrCode = new QRCode(qrContainer, {
                                text: compressed,
                                width: 256,
                                height: 256,
                                colorDark: '#000000',
                                colorLight: '#ffffff',
                                correctLevel: QRCode.CorrectLevel.L
                            });
                        }
                    }
                },

                refreshSave() {
                    this.generateSaveCode();
                    alert('Save code updated! 📱');
                },

                copyCode() {
                    const code = this.currentSaveCode;
                    
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(code).then(() => {
                            alert('Code copied! 📋\n\n' + code);
                        }).catch(() => {
                            alert('Your code: ' + code + '\n\nWrite this down!');
                        });
                    } else {
                        alert('Your code: ' + code + '\n\nWrite this down!');
                    }
                },

                loadData() {
                    const input = document.getElementById('loadCodeInput').value.trim();
                    
                    if (!input) {
                        alert('Please enter a code or scan a QR code! 🤔');
                        return;
                    }
                    
                    let compressed = null;
                    
                    // Check if it's a short manual code
                    if (input.length < 10) {
                        const allCodes = JSON.parse(localStorage.getItem('wca2025_codes') || '{}');
                        compressed = allCodes[input.toUpperCase()];
                        
                        if (!compressed) {
                            alert('Code not found! Please check and try again. 🔍');
                            return;
                        }
                    } else {
                        // Assume it's the full base64 data from QR code
                        compressed = input;
                    }
                    
                    try {
                        const jsonStr = atob(compressed);
                        const saveData = JSON.parse(jsonStr);
                        
                        // Restore data
                        if (saveData.p) WCAGuideApp.userProgress.predictions = saveData.p;
                        if (saveData.r) WCAGuideApp.userProgress.results = saveData.r;
                        if (saveData.g) WCAGuideApp.userProgress.gameScores = saveData.g;
                        
                        WCAGuideApp.saveProgress();
                        
                        alert('Data loaded successfully! ✅\n\nYour progress has been restored!');
                        document.getElementById('loadCodeInput').value = '';
                        
                        // Refresh current screen
                        WCAGuideApp.scores.init();
                        WCAGuideApp.storage.generateSaveCode();
                        
                    } catch (e) {
                        alert('Invalid code! Please try again. 🤷');
                    }
                }
            }
        };

        // Initialize app when page loads
        window.addEventListener('DOMContentLoaded', () => {
            try {
                WCAGuideApp.init();
                console.log('WCA Guide App initialized successfully');
            } catch (error) {
                console.error('Error initializing app:', error);
                alert('Error loading app. Please refresh the page.');
            }
        });

        // Cleanup when page unloads
        window.addEventListener('beforeunload', () => {
            if (WCAGuideApp.countdownInterval) {
                clearInterval(WCAGuideApp.countdownInterval);
            }
        });
        
        // Make app globally accessible for onclick handlers
        window.WCAGuideApp = WCAGuideApp;
    </script>
</body>
</html>
